{"meta":{"title":"Ezksd","subtitle":"ezksd's blog","description":null,"author":"ezksd","url":"https://ezksd.github.io","root":"/"},"pages":[{"title":"About","date":"2020-07-29T11:47:51.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"about/index.html","permalink":"https://ezksd.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-02-05T11:17:40.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"categories/index.html","permalink":"https://ezksd.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-02-05T11:17:26.000Z","updated":"2021-06-26T13:14:30.037Z","comments":true,"path":"tags/index.html","permalink":"https://ezksd.github.io/tags/index.html","excerpt":"","text":"&lt;%- tagcloud({min_font: 20, max_font: 20, unit: px, amount:30, color: true, start_color: #b700ff, end_color: #b700ff, level: 3}) %&gt;"}],"posts":[{"title":"Java DIRECT IO","slug":"java-direct-io","date":"2021-01-09T15:09:47.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2021/01/09/java-direct-io/","link":"","permalink":"https://ezksd.github.io/2021/01/09/java-direct-io/","excerpt":"","text":"java 10 æ”¯æŒäº†DIRECT IOï¼Œå¯ä»¥ç»•è¿‡page cacheç›´æ¥å†™æ–‡ä»¶ã€‚ 12Path path = Paths.get(&quot;test.txt&quot;);FileChannel channel = FileChannel.open(path, StandardOpenOption.WRITE, ExtendedOpenOption.DIRECT); DIRECT IOéœ€è¦å¯¹é½ï¼Œä½†æ˜¯ä»–æœ‰ä¸€äº›éå¸¸å¾®å¦™çš„åœ°æ–¹ã€‚ é‚£äº›åœ°æ–¹éœ€è¦å¯¹é½ï¼š123Util.checkChannelPositionAligned(position(), alignment);Util.checkBufferPositionAligned(bb, pos, alignment);Util.checkRemainingBufferSizeAligned(rem, alignment); åˆ†åˆ«æ˜¯ï¼š æ–‡ä»¶å†™å…¥ä½ç½® directBufferèµ·å§‹åœ°å€ directBufferä¸­å‰©ä½™æ•°æ®çš„é•¿åº¦ ä»–ä»¬éƒ½å¿…é¡»æ˜¯alignmentçš„æ•´æ•°å€ã€‚ æŒ‰å¤šå°‘å­—èŠ‚å¯¹é½ï¼Ÿ12345678910111213141516171819202122232425262728JNIEXPORT jint JNICALLJava_sun_nio_ch_FileDispatcherImpl_setDirect0(JNIEnv *env, jclass clazz, jobject fdo)&#123; jint fd = fdval(env, fdo); jint result;#ifdef MACOSX struct statvfs file_stat;#else struct statvfs64 file_stat;#endif#ifdef MACOSX result = fstatvfs(fd, &amp;file_stat);#else result = fstatvfs64(fd, &amp;file_stat);#endif if(result == -1) &#123; JNU_ThrowIOExceptionWithLastError(env, &quot;DirectIO setup failed&quot;); return result; &#125; else &#123; result = (int)file_stat.f_frsize; &#125;#else result == -1;#endif return result;&#125; statvfs.frsizeæ˜¯æ–‡ä»¶ç³»ç»Ÿçš„é€»è¾‘å—å¤§å°ï¼Œå¯èƒ½åŒ…å«å¤šä¸ªç‰©ç†å—ã€‚ unsigned long f_frsize; /* Fragment size */ å¦‚ä½•è·å¾—èµ·å§‹èµ·å§‹ä½ç½®æ˜¯å¯¹é½çš„directBufferç³»ç»Ÿåˆ†é…çš„å†…å­˜è™šæ‹Ÿåœ°å€å¹¶ä¸ç¡®å®šï¼Œéœ€è¦åˆ†é…å¤§ä¸€äº›çš„ç©ºé—´(pagesize + capcity)ï¼Œåªä½¿ç”¨å…¶ä¸­çš„ä¸€éƒ¨åˆ†ã€‚ 1long size = Math.max(1L, (long)cap + (pa ? ps : 0)); å‡å¦‚è®¾ç½®äº†-Dsun.nio.PageAlignDirectMemory=trueå‚æ•°ä¼šè‡ªåŠ¨å¯¹é½ã€‚ æ³¨ï¼šè¿™åœºjdké‡Œçš„æ³¨é‡Šæ˜¯é”™çš„ï¼Œ-XX:MaxDirectMemorySize=æ²¡æœ‰ä»»ä½•ä½œç”¨ è¿™é‡ŒDirectByteBufferä¼šæŠŠæ•´æ®µåˆ†é…çš„å†…å­˜å†™0ï¼Œè€Œä¸ä»…ä»…æ˜¯ç”¨åˆ°çš„éƒ¨åˆ†ã€‚å¯¼è‡´æ²¡ç”¨åˆ°çš„è™šæ‹Ÿå†…å­˜ä¹Ÿä¼šåˆ†é…ç‰©ç†å†…å­˜ã€‚ 1234567891011121314long base = 0;try &#123; base = UNSAFE.allocateMemory(size);&#125; catch (OutOfMemoryError x) &#123; Bits.unreserveMemory(size, cap); throw x;&#125;UNSAFE.setMemory(base, size, (byte) 0);if (pa &amp;&amp; (base % ps != 0)) &#123; // Round up to page boundary address = base + ps - (base &amp; (ps - 1));&#125; else &#123; address = base;&#125; å‡è®¾åˆ†é…ä¸€é¡µå†…å­˜ï¼Œè™šæ‹Ÿåœ°å€æ¨ªè·¨ä¸¤é¡µï¼Œæœ€ç»ˆä¼šå¯¼è‡´åˆ†é…ä¸¤å€çš„ç‰©ç†å†…å­˜ã€‚å¦‚æœåˆ†é…å°é‡å†…å­˜æˆ–è€…å¼€å¯å¤§é¡µæƒ…å†µå¯èƒ½ä¼šæ›´ä¸¥é‡ã€‚ 12345678910111213141516public class Hello &#123; static final int _4K = 4096; static Object[] save = new Object[256 * 1024]; public static void main(String[] args) &#123; for (int i = 0; i &lt; 256 * 1024; i++) &#123; ByteBuffer buffer = ByteBuffer.allocateDirect(_4K); save[i] = buffer; &#125; try &#123; new CountDownLatch(1).await(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; è¿™ä»½ä»£ç ä¸å¸¦å¯¹é½å‚æ•°å ç”¨çš„ç‰©ç†å†…å­˜çº¦ä¸º1Gï¼Œè€ŒåŠ ä¸Š-Dsun.nio.PageAlignDirectMemory=trueå°†å ç”¨2Gã€‚ 1234567$ java -XX:NativeMemoryTracking=summary -XX:MaxDirectMemorySize=1g -Dsun.nio.PageAlignDirectMemory=true Hello$ jcmd 29084 VM.native_memory29084:Native Memory Tracking:Total: reserved=7840547KB, committed=2470423KB- Other (reserved=2097152KB, committed=2097152KB) (malloc=2097152KB #262144) æ³¨æ„åˆ°-XX:MaxDirectMemorySize=1gï¼Œä½†æ˜¯DirectMemoryè¿œè¿œè¶…å‡ºäº†1gã€‚ MaxDirectMemorySizeçš„é€»è¾‘Bits.tryReserveMemoryæ˜¯æŒ‰åˆ†é…çš„å®¹é‡ç®—çš„ï¼Œè€Œä¸æ˜¯å®é™…åˆ†é…çš„å†…å­˜å¤§å°ã€‚ 12345678910111213141516private static boolean tryReserveMemory(long size, int cap) &#123; // -XX:MaxDirectMemorySize limits the total capacity rather than the // actual memory usage, which will differ when buffers are page // aligned. long totalCap; while (cap &lt;= MAX_MEMORY - (totalCap = TOTAL_CAPACITY.get())) &#123; if (TOTAL_CAPACITY.compareAndSet(totalCap, totalCap + cap)) &#123; RESERVED_MEMORY.addAndGet(size); COUNT.incrementAndGet(); return true; &#125; &#125; return false;&#125; è€Œåœ¨å¼€å¯å¯¹é½çš„æ—¶å€™size = cap + pageSizeï¼Œæ˜¾ç„¶sizeè¦æ¯”capå¤§å¾—å¤šã€‚","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Javaç±»å‹ç³»ç»Ÿ","slug":"java-type-system","date":"2020-12-31T00:48:14.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/12/31/java-type-system/","link":"","permalink":"https://ezksd.github.io/2020/12/31/java-type-system/","excerpt":"","text":"ÎºiÎ¶sãƒ¤ç•¶éä¸»æµæˆç‚ºä¸»æµã‚·\bjavaä¸€ç›´æ˜¯é¢å‘å¯¹è±¡è¯­è¨€çš„ä»£è¡¨ã€‚ç›®å‰å¤§éƒ¨åˆ†è¯­è¨€éƒ½æ”¯æŒé¢å‘å¯¹è±¡ï¼ŒåŒæ—¶é¢å‘å¯¹è±¡çš„æ¦‚å¿µä¹Ÿå˜å¾—æ¨¡ç³Šã€‚ Javaçš„é¢å‘å¯¹è±¡ä¸»è¦æœ‰ä¸¤ç‚¹ï¼š æ•°æ®å’Œå‡½æ•°æ‰“åŒ…ï¼Œåœ¨è¿™é‡Œå‡½æ•°ç§°ä¸ºæ–¹æ³•ï¼Œä»–çš„ç¬¬ä¸€ä¸ªå‚æ•°é»˜è®¤æ˜¯thisã€‚ åŸºäºç»§æ‰¿å’Œå­ç±»å‹çš„ç±»å‹ç³»ç»Ÿã€‚ è¿™ä¸¤ç‚¹åˆæœ‰ä¸€ç‚¹äº¤å‰ï¼ŒthisæŒ‡å‘çš„å¯¹è±¡ç±»å‹ä¸åŒï¼Œä¼šåˆ†æ´¾åˆ°ä¸åŒçš„æ–¹æ³•ï¼ˆè™šæ–¹æ³•ï¼‰ã€‚è€Œå¯¹äºç¬¬ä¸€ç‚¹ï¼Œä»–åˆå’Œé—­åŒ…ç±»ä¼¼ï¼ŒJava8ä»¥å‰ç”¨å¯¹è±¡æ¥æ¨¡æ‹Ÿå‡½æ•°ï¼Œäº‹å®ä¸Šå±•ç¤ºäº†ä¸¤è€…çš„å…±æ€§ã€‚è€Œè¿™ç§è®¾è®¡æš—ç¤ºå¯¹è±¡æ˜¯æœ‰çŠ¶æ€çš„ï¼Œè¿™ç§è®¾è®¡å’Œå‡½æ•°å¼ä¸åŒã€‚åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œå¯å˜çŠ¶æ€åº”è¯¥ä»å‚æ•°ä¸­ä¼ å…¥ï¼Œä»è¿”å›å€¼ä¸­å–å‡ºã€‚ è€Œç¬¬äºŒç‚¹ï¼Œä¸€ç›´è¢«å„ç§é»‘çš„å‡èŒƒå‹ï¼Œä»¥åŠä¸ºäº†å…¼å®¹è£¸ç±»å‹åšå‡ºçš„å¦¥åï¼ˆé€šé…ç¬¦ï¼‰ï¼Œä¹Ÿæ˜¯è¿™ä¸ªè¯­è¨€æœ€ç‹¬ç‰¹ï¼ˆæ¶å¿ƒï¼‰çš„åœ°æ–¹ã€‚ ä¸€ä¸ªåç›´è§‰çš„ä¾‹å­1234567static &lt;E&gt; void test(List&lt;E&gt; l1,List&lt;E&gt; l2)&#123;&#125;public static void main(String[] args) &#123; List&lt;?&gt; list = new ArrayList&lt;&gt;(); test(list, list);&#125; 123456789101112Main.java:12: error: method test in class Main cannot be applied to given types; test(list, list); ^ required: List&lt;E&gt;,List&lt;E&gt; found: List&lt;CAP#1&gt;,List&lt;CAP#2&gt; reason: inference variable E has incompatible equality constraints CAP#2,CAP#1 where E is a type-variable: E extends Object declared in method &lt;E&gt;test(List&lt;E&gt;,List&lt;E&gt;) where CAP#1,CAP#2 are fresh type-variables: CAP#1 extends Object from capture of ? CAP#2 extends Object from capture of ?1 error é”™è¯¯æç¤ºäº†è¿™ä¸¤ä¸ªList&lt;E&gt;ä¸æ˜¯ä¸€ä¸ªä¸œè¥¿ï¼Œåœ¨ä¸åŒçš„åœ°æ–¹ä»£è¡¨ç€ä¸åŒçš„ç±»å‹ã€‚å‡å¦‚æˆ‘ä»¬æƒ³æš—ç¤ºä¸¤ä¸ªå‚æ•°æ˜¯åŒä¸€ä¸ªç±»å‹ï¼Œåƒè¿™æ ·ï¼š 1234567static &lt;E,L extends List&lt;E&gt;&gt; void test(L l1,L l2)&#123;&#125;public static void main(String[] args) &#123; List&lt;?&gt; list = new ArrayList&lt;&gt;(); test(list, list);&#125; 12345678910111213Main.java:12: error: method test in class Main cannot be applied to given types; test(list, list); ^ required: L,L found: List&lt;CAP#1&gt;,List&lt;CAP#2&gt; reason: inference variable E has incompatible equality constraints CAP#1,CAP#2 where L,E are type-variables: L extends List&lt;E&gt; declared in method &lt;E,L&gt;test(L,L) E extends Object declared in method &lt;E,L&gt;test(L,L) where CAP#1,CAP#2 are fresh type-variables: CAP#1 extends Object from capture of ? CAP#2 extends Object from capture of ?1 error ä¾ç„¶ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼Œé—®é¢˜åœ¨äºListçš„å…ƒç´ ç±»å‹å¯¹ä¸ä¸Šã€‚äºæ˜¯æˆ‘ä»¬åŠ ä¸Š? extends Eï¼Œl1å’Œl2çš„ç±»å‹å‚æ•°ä¾ç„¶ä¸åŒï¼Œä½†è¿™ä¸€æ¬¡Eä»£è¡¨è¿™ä¸¤ä¸ªç±»å‹çš„å…±åŒä¸Šç•Œã€‚ 1234567static &lt;E,L extends List&lt;? extends E&gt;&gt; void test(L l1,L l2)&#123;&#125;public static void main(String[] args) &#123; List&lt;?&gt; list = new ArrayList&lt;&gt;(); test(list, list);&#125; å­˜åœ¨ç±»å‹æ­¤å¤„ä¸æ·±å…¥è®¨è®ºç±»å‹è®ºï¼Œè€Œä¸”æˆ‘ä¹Ÿä¸æ‡‚ï¼Œä»…å±•ç¤ºå­˜åœ¨ç±»å‹å’ŒèŒƒå‹ä¹‹é—´çš„åŒºåˆ«ã€‚ä»¥Rustä¸ºä¾‹ï¼Œè¿™ä¸ªè¯­è¨€å°±ä¸æ”¯æŒå­ç±»å‹ï¼ŒåŒæ—¶Rustä¸­çš„é—­åŒ…åˆå¦‚æ­¤ç‰¹åˆ«ã€‚æ¯”å¦‚ï¼š 123456fn main() &#123; let i = 0; let j = 1; let mut f = || i; f = || j;&#125; 123= note: expected closure `[closure@src/main.rs:4:17: 4:21]` found closure `[closure@src/main.rs:5:9: 5:13]`= note: no two closures, even if identical, have the same type ä¸–ç•Œä¸Šæ²¡æœ‰ä¸¤ç‰‡ç›¸åŒçš„å¶å­ï¼ŒRusté‡Œä¹Ÿæ²¡æœ‰ä¸¤ä¸ªç›¸åŒçš„closuure è€Œä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„ä¸œè¥¿ï¼Œåœ¨ä¸æ”¯æŒå­ç±»å‹çš„åŒæ—¶ï¼Œè¦å¦‚ä½•è¡¨ç¤ºä»–çš„ç±»å‹å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯å­˜åœ¨ç±»å‹ã€‚ 1234fn closure() -&gt; impl Fn() -&gt; i32&#123; let i = 1; move || i&#125; è¿”å›å€¼åœ¨å‡½æ•°å†…éƒ¨ç»™å‡ºï¼Œæ­¤æ—¶ç¼–è¯‘å™¨å·²ç»ä¸èƒ½é€šè¿‡ç±»å‹æ¨å¯¼æ¥å¸®æˆ‘ä»¬åšå†³å®šäº†ï¼Œè¿™ä¹Ÿæ˜¯å­˜åœ¨ç±»å‹åœ¨Rustä¸­çš„ç”¨å¤„ã€‚ å›åˆ°javajavaçš„èŒƒå‹ä¹Ÿæœ‰ä¸€äº›ç±»ä¼¼ï¼Œä»–æ˜¯ä¸å˜çš„ï¼ˆç›¸å¯¹äºåå˜å’Œé€†å˜ï¼‰ï¼Œæ¯”å¦‚å¸¸è§çš„ä¾‹å­: 123456interface Fruit &#123;&#125;static class Apple implements Fruit&#123;&#125;public static void main(String[] args) &#123; LinkedList&lt;Fruit&gt; list = new LinkedList&lt;Apple&gt;();&#125; 1java: incompatible types: java.util.LinkedList&lt;com.company.Main.Apple&gt; cannot be converted to java.util.LinkedList&lt;com.company.Main.Fruit&gt; è¿™ä¸ªä¾‹å­æ˜¯ä¸€ä¸ªåå˜çš„é€»è¾‘ï¼Œè€ŒList&lt;Fruit&gt;çš„åœ¨ç±»å‹å‚æ•°Fruitå¤„æ˜¯ä¸å˜çš„ã€‚javaçš„åå˜ä¸å…¶ä»–è¯­è¨€ï¼ˆc#,scala)åŒºåˆ«åœ¨äºjavaçš„åå˜é€»è¾‘åœ¨ä½¿ç”¨çš„æ—¶å€™ç»™å‡ºï¼Œè€Œå…¶ä»–è¯­è¨€åœ¨å®šä¹‰çš„æ—¶å€™ç»™å‡ºã€‚æˆ–è€…è¯´ä»–å¯èƒ½å’Œåå˜æœ¬èº«å°±ä¸ä¸€æ ·ï¼Œjavaè¯­è¨€è§„èŒƒä¸­å…³äºåå˜å”¯äºŒæåˆ°çš„éƒ¨åˆ†æ˜¯è™šæ–¹æ³•ä¸­çš„è¿”å›å€¼åå˜ï¼Œä»¥åŠåå˜è¿”å›å€¼æ–¹æ³•å’Œæ–¹æ³•è¦†ç›–ä¹‹é—´çš„å…³ç³»ã€‚ è€Œè¿™ä¸€ç‚¹ä¹ŸåŒæ ·æŒ‡å‡ºäº†è¿”å›å€¼å’Œå‚æ•°ç±»å‹æ¨å¯¼çš„ä¸åŒã€‚ 123List&lt;String&gt; test()&#123; return (List&lt;? extends String&gt;)null;&#125; æ˜¾ç„¶è¿™ä»½ä»£ç ä¹Ÿæ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºè¿”å›å€¼åå˜çš„å‰ææ˜¯è¿”å›å€¼çš„ç±»å‹å¿…é¡»æ˜¯æ–¹æ³•æ ‡å‡ºçš„è¿”å›å€¼ç±»å‹çš„å­ç±»å‹ã€‚ å¦‚ä½•ç†è§£å­˜åœ¨ç±»å‹å¦‚æ­¤éš¾ä»¥ç†è§£å’Œåç›´è§‰ï¼Œåœ¨Rustè¯­è¨€ä¸­ä¹ŸåŒæ ·æ˜¯ä¸€ä¸ªæ§›ã€‚å’Œå…¶ä»–çš„è¯­æ³•é™åˆ¶ä¸€æ ·ï¼Œä»–åŒ…å«ä¸¤éƒ¨åˆ†ï¼š å¦‚ä½•ç†è§£è¯­æ³•æœ¬èº« åœ¨é™åˆ¶ä¹‹ä¸‹å¦‚ä½•å»å†™ä»£ç  æˆ‘è®¤ä¸ºç¬¬äºŒéƒ¨åˆ†æ›´åŠ é‡è¦ï¼Œæ¯”å¦‚Rustçš„lifetimeå’Œownershipæœ¬èº«å¹¶ä¸éš¾ç†è§£ï¼Œä½†æ˜¯å½¢æˆä¸€å¥—ä»€ä¹ˆæ ·çš„ä»£ç æ˜¯åˆæ³•çš„ç›´è§‰ç›¸å½“çš„å›°éš¾ã€‚ ä»è¿™ä¸€ç‚¹ä¸Šæ¥è¯´ï¼Œåœ¨ä»€ä¹ˆæ—¶å€™ç”¨åå˜é€†å˜å¯ä»¥å‚è€ƒscalaçš„è¯´æ³•ï¼š These positions are classied as covariant for the types of immutable fields and method results, and contravariant for method argument types and upper type parameter bounds. Type arguments to a non-variant type parameter are always in non-variant position. The position flips between contra- and co-variant inside a type argument that corresponds to a contravariant parameter. The type system enforces that covariant (respectively, contravariant) type parameters are only used in covariant (contravariant) positions. ç®€è¦æ¥è¯´ä»£è¡¨ä¸å¯å˜çš„å­—æ®µå’Œè¿”å›å€¼çš„ç±»å‹å‚æ•°æ˜¯åå˜çš„ï¼Œè€Œä»£è¡¨æ–¹æ³•çš„å‚æ•°å’Œç±»å‹å‚æ•°ä¸Šç•Œçš„ç±»å‹å‚æ•°æ˜¯é€†å˜çš„ï¼Œåœ¨é€†å˜å‚æ•°çš„å†…éƒ¨å/é€†å˜åˆæ˜¯åè¿‡æ¥çš„ã€‚ä»–ä»¬åŒæ—¶å‡ºç°çš„æ—¶å€™å°±ä¼šç‰¹åˆ«é˜´é—´ï¼š 123public static &lt;T&gt; void sort(List&lt;? extends Comparable&lt;? super T&gt;&gt; list) &#123; list.sort(null);&#125; è¿™æ˜¯æ ‡å‡†åº“ä¸­çš„ä»£ç ï¼ŒListçš„å…ƒç´ ç±»å‹æ˜¯åå˜çš„ï¼ŒComparableçš„ç±»å‹å‚æ•°æ˜¯compareToçš„å‚æ•°çš„ç±»å‹æ˜¯é€†å˜çš„ã€‚ åå˜ç›¸å¯¹äºé€†å˜æ›´å®¹æ˜“ç†è§£ï¼Œä¸€ä¸ªé›†åˆç±»å‹å­˜å‚¨ç€ä¸åŒçš„å…ƒç´ ï¼Œè¿™äº›å…ƒç´ æœ‰å…¬å…±çˆ¶ç±»å‹ã€‚ä½†åå˜çš„å‰ææ˜¯é›†åˆä¸å¯å˜ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆjavaçš„åå˜æ•°ç»„æ˜¯æœ‰é—®é¢˜çš„ã€‚ 12345678interface Fruit &#123;&#125;static class Apple implements Fruit&#123;&#125;static class Orange implements Fruit&#123;&#125;public static void main(String[] args) &#123; Fruit[] fruit = new Apple[1]; fruit[0] = new Orange();&#125; 12Exception in thread &quot;main&quot; java.lang.ArrayStoreException: com.company.Main$Orange at com.company.Main.main(Main.java:17) è€Œç†è§£é€†å˜çš„å…³é”®åœ¨äºåº”è¯¥æŠŠå‡½æ•°ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè€Œä¸æ˜¯å•ç‹¬å»çœ‹ç±»å‹å‚æ•°ä¸ºä»€ä¹ˆåº”è¯¥æ˜¯ä¸‹ç•Œï¼ˆsuper)ã€‚å¯å˜æ€§æœ¬èº«æè¿°çš„å°±æ˜¯å‡å¦‚Aæ˜¯Bçš„å­ç±»å‹ï¼Œä¸¤ä¸ªå€¼ä¹‹é—´çš„å­ç±»å‹å…³ç³»ã€‚è€Œå¯¹äºå‡½æ•°æ¥è¯´ï¼Œä¸€ä¸ªå‡½æ•°ç±»å‹Aå¯¹äºå¦ä¸€ä¸ªå‡½æ•°ç±»å‹Bé€‚ç”¨é¢æ›´å¹¿ï¼Œé‚£ä¹ˆAç±»å‹çš„å€¼å¯ä»¥å‡ºç°åœ¨è¦æ±‚å‡ºç°Bç±»å‹çš„åœ°æ–¹ã€‚ ä»¥æ°´æœä¸ºä¾‹ï¼Œå‡è®¾æ°´æœä¹‹é—´å¯ä»¥æ¯”è¾ƒé‡é‡ã€‚å¦‚æœä¸æ ‡å‡ºä¸‹ç•Œï¼Œçˆ¶ç±»å·²ç»å®ç°äº†Comparableæ¥å£ï¼Œä½†æ˜¯ä¸èƒ½ç¼–è¯‘é€šè¿‡ï¼Œè¿™æ— å½¢ä¸­é™åˆ¶äº†ä»£ç çš„è¡¨è¾¾èƒ½åŠ›ã€‚ 12345678910111213141516interface Fruit extends Comparable&lt;Fruit&gt; &#123; @Override default int compareTo(Fruit o)&#123; return 0; &#125;&#125;static class Apple implements Fruit&#123;&#125;static &lt;T extends Comparable&lt;T&gt;&gt; void sort1(List&lt;T&gt; list) &#123;&#125;static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort2(List&lt;T&gt; list) &#123;&#125;public static void main(String[] args)&#123; ArrayList&lt;Apple&gt; list = new ArrayList&lt;&gt;(); sort1(list); //ç¼–è¯‘é”™è¯¯ sort2(list); //åˆæ³•&#125; javaé‡Œè¿˜æœ‰ä¸€äº›é«˜çº§ç‰¹æ€§ï¼Œä¸è¿‡é€‚ç”¨èŒƒå›´æ¯”è¾ƒå±€é™äº¤ç±»å‹1234567891011class A&#123; void ha()&#123;&#125;&#125;interface B&#123; void he();&#125;&lt;T extends A &amp; B&gt; void fun(T t)&#123; t.ha(); t.he();&#125; ç”±äºJavaæœ¬èº«ä¸æ”¯æŒå¤šç»§æ‰¿ï¼Œäº¤ç±»å‹é‡Œåªèƒ½æœ‰ä¸€ä¸ªclassè€Œä¸”åªèƒ½æ”¾åœ¨ç¬¬ä¸€ä½ã€‚ å¹¶ç±»å‹123456789101112131415class A extends Exception&#123;&#125;class B extends Exception&#123;&#125;void fun()&#123; try &#123; if(flag) throw new A(); else throw new B(); &#125; catch (A | B a) &#123; a.printStackTrace(); &#125;&#125; åªèƒ½åœ¨å¼‚å¸¸å—ä¸­ä½¿ç”¨ï¼Œè¡¨ç¤ºå¯èƒ½å‡ºç°çš„å¼‚å¸¸ç±»å‹ã€‚","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"},{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"}],"tags":[]},{"title":"NIOå’Œepollçš„å…³ç³»","slug":"nio","date":"2020-08-27T18:15:14.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/08/27/nio/","link":"","permalink":"https://ezksd.github.io/2020/08/27/nio/","excerpt":"","text":"nioåœ¨linuxå¯¹åº”çš„å®ç°æ˜¯epollã€‚åœ¨linuxä¸­ï¼Œæ‰€æœ‰I/Oéƒ½æŠ½è±¡ä¸ºæ–‡ä»¶ï¼ˆåŒ…æ‹¬ç½‘ç»œå’Œæ–‡ä»¶è¯»å†™)ï¼Œç”¨æ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰æ¥æ ‡è¯†ã€‚fdæ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ï¼Œ å…¶ä¸­0ï¼Œ1ï¼Œ2åˆ†åˆ«å¯¹åº”stdinï¼Œstdoutï¼Œstderrã€‚epollåŒ…å«ä¸‰ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«æ˜¯ï¼š epoll_createï¼šåˆ›å»ºä¸€ä¸ªepoll instanceå¹¶è¿”å›ä¸€ä¸ªfdä»£è¡¨ä»–ï¼Œå¯¹åº”Selectorã€‚ epoll_ctlï¼šæ³¨å†ŒI/Oäº‹ä»¶ï¼Œå¯¹åº”SelectableChannel.register()ã€‚ epoll_waitï¼šç­‰å¾…I/Oäº‹ä»¶ï¼Œå¯¹åº”Selector.select()ã€‚ OP_ACCEPT å’Œ OP_CONNECT EPOLLIN The associated file is available for read(2) operations. EPOLLOUT The associated file is available for write(2) operations. EPOLLRDHUP (since Linux 2.6.17) Stream socket peer closed connection, or shut down writing half of connection. (This flag is especially useful for writâ€ ing simple code to detect peer shutdown when using edge-trigâ€ gered monitoring.) EPOLLPRI There is an exceptional condition on the file descriptor. See the discussion of POLLPRI in poll(2). EPOLLERR Error condition happened on the associated file descriptor. This event is also reported for the write end of a pipe when the read end has been closed. epoll_wait(2) will always report for this event; it is not necessary to set it in events when calling epoll_ctl(). EPOLLHUP Hang up happened on the associated file descriptor. epoll_wait(2) will always wait for this event; it is not necâ€ essary to set it in events when calling epoll_ctl(). Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer closed its end of the channel. Subsequent reads from the channel will return 0 (end of file) only after all outstanding data in the channel has been consumed. EPOLLET Requests edge-triggered notification for the associated file descriptor. The default behavior for epoll is level-trigâ€ gered. See epoll(7) for more detailed information about edge- triggered and level-triggered notification. This flag is an input flag for the event.events field when calling epoll_ctl(); it is never returned by epoll_wait(2). EPOLLONESHOT (since Linux 2.6.2) Requests one-shot notification for the associated file deâ€ scriptor. This means that after an event notified for the file descriptor by epoll_wait(2), the file descriptor is disâ€ abled in the interest list and no other events will be reâ€ ported by the epoll interface. The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask. This flag is an input flag for the event.events field when calling epoll_ctl(); it is never returned by epoll_wait(2). å¯ä»¥æ³¨æ„åˆ°ï¼Œå’ŒSelectionKeyä¸­çš„äº‹ä»¶æœ‰ä¸€äº›å·®åˆ«ï¼Œæ¯”å¦‚è¿™é‡Œæ²¡æœ‰OP_ACCEPTå’ŒOP_CONNECTã€‚é‚£ä¹ˆè¿™ä¸¤ä¸ªäº‹ä»¶æ˜¯åšä»€ä¹ˆçš„ğŸ¤”ï¼Ÿ ACCEPT123456public int translateInterestOps(int ops) &#123; int newOps = 0; if ((ops &amp; SelectionKey.OP_ACCEPT) != 0) newOps |= Net.POLLIN; return newOps;&#125; OP_ACCEPTå˜æˆäº†Net.POLLINã€‚è€Œå¯¹äºCONNECTï¼š 12345678910public int translateInterestOps(int ops) &#123; int newOps = 0; if ((ops &amp; SelectionKey.OP_READ) != 0) newOps |= Net.POLLIN; if ((ops &amp; SelectionKey.OP_WRITE) != 0) newOps |= Net.POLLOUT; if ((ops &amp; SelectionKey.OP_CONNECT) != 0) newOps |= Net.POLLCONN; return newOps;&#125; POLLCONNå’ŒPOLLOUTä¸€æ ·å‡ä¸º4ï¼Œé€šè¿‡socketçš„çŠ¶æ€è¿›è¡ŒåŒºåˆ†ã€‚å¦‚æœsocketæœªè¿æ¥ä»£è¡¨OP_CONNECT,å·²è¿æ¥ä»£è¡¨OP_WRITEã€‚å¦‚æœè¯´æŠŠPOLLINæ‹†åˆ†æˆACCEPTå’ŒREADå°šå¯ç†è§£ï¼Œé‚£æŠŠOUTæ‹†æˆWRITEå’ŒCONNECTæ˜¯ä¸ºä»€ä¹ˆï¼Ÿ OP_CONNECTæ˜¯åœ¨åšä»€ä¹ˆè¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸å®¹æ˜“è¯¯è§£çš„åœ°æ–¹ï¼Œå®¢æˆ·ç«¯è°ƒç”¨connect,æœåŠ¡ç«¯è°ƒè§¦å‘OP_ACCEPTäº‹ä»¶ï¼Œè°ƒç”¨acceptä¹‹åå®¢æˆ·ç«¯è§¦å‘OP_CONNECTäº‹ä»¶ï¼Œè°ƒç”¨finishConnectã€‚çœ‹ä¸Šå»å’Œä¸‰æ¬¡æ¡æ‰‹å®Œå…¨ä¸€è‡´ï¼Œä½†å®Œå…¨ä¸æ˜¯é‚£å›äº‹ï¼Œé€šè¿‡wiresharkè°ƒè¯•å¾—çŸ¥åœ¨æœåŠ¡ç«¯è°ƒç”¨acceptæ—¶ä¸‰æ¬¡æ¡æ‰‹å·²ç»å®Œæˆäº†ã€‚é‚£ä¹ˆOP_CONNECTå’ŒfinishConnectåˆ†åˆ«æ˜¯åœ¨åšä»€ä¹ˆï¼Ÿ 1boolean polled = Net.pollConnectNow(fd); è¿™æ˜¯ä¸€ä¸ªnativeæ–¹æ³•ï¼š 12345678910111213jint fd = fdval(env, fdo);struct pollfd poller;int result;poller.fd = fd;poller.events = POLLOUT;poller.revents = 0;if (timeout &lt; -1) &#123; timeout = -1;&#125; else if (timeout &gt; INT_MAX) &#123; timeout = INT_MAX;&#125;result = poll(&amp;poller, 1, (int)timeout); å¯ä»¥çœ‹åˆ°jniæ–¹æ³•åªæ˜¯åœ¨ç”¨poll()æ£€æŸ¥è¯¥fdçš„POLLOUTäº‹ä»¶ã€‚è€ŒPOLLOUTè¡¨ç¤ºsocketç¼“å†²åŒºå¯å†™ï¼Œéšå«è¿æ¥å·²ç»å»ºç«‹ã€‚æ‰€ä»¥å¯¹äºé˜»å¡çš„finishConnect()ï¼Œä»–ä¼šé˜»å¡åˆ°è¿æ¥å»ºç«‹ï¼Œè€Œéé˜»å¡çš„finishConnectï¼Œç”¨è¿”å›å€¼ä»£è¡¨è¿æ¥æ˜¯å¦å»ºç«‹ã€‚è¿™ä¸ªæ–¹æ³•åå¾ˆæœ‰è¯¯å¯¼æ€§ï¼Œå»ºè®®æ”¹ä¸ºdoesItFinishConnectï¼Œæˆ–è€…è¯´éé˜»å¡çš„connectå¥½åƒç”¨å¤„ä¸å¤§ã€‚ é”™è¯¯epolläº‹ä»¶è½¬æ¢ä¸ºNIOäº‹ä»¶ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl sk) &#123; int intOps = sk.nioInterestOps(); // Do this just once, it synchronizes int oldOps = sk.nioReadyOps(); int newOps = initialOps; if ((ops &amp; Net.POLLNVAL) != 0) &#123; // This should only happen if this channel is pre-closed while a // selection operation is in progress // ## Throw an error if this channel has not been pre-closed return false; &#125; if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) &#123; newOps = intOps; sk.nioReadyOps(newOps); // No need to poll again in checkConnect, // the error will be detected there readyToConnect = true; return (newOps &amp; ~oldOps) != 0; &#125; if (((ops &amp; Net.POLLIN) != 0) &amp;&amp; ((intOps &amp; SelectionKey.OP_READ) != 0) &amp;&amp; (state == ST_CONNECTED)) newOps |= SelectionKey.OP_READ; if (((ops &amp; Net.POLLCONN) != 0) &amp;&amp; ((intOps &amp; SelectionKey.OP_CONNECT) != 0) &amp;&amp; ((state == ST_UNCONNECTED) || (state == ST_PENDING))) &#123; newOps |= SelectionKey.OP_CONNECT; readyToConnect = true; &#125; if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp; ((intOps &amp; SelectionKey.OP_WRITE) != 0) &amp;&amp; (state == ST_CONNECTED)) newOps |= SelectionKey.OP_WRITE; sk.nioReadyOps(newOps); return (newOps &amp; ~oldOps) != 0;&#125; å¯ä»¥çœ‹å‡ºï¼š POLLNVALæ²¡æœ‰è®¾ç½®ä»»ä½•ReadyOpsï¼ŒPOLLNAVALçš„å€¼ä¸º32ï¼Œåœ¨ä¸Šè¡¨ä¸­æ²¡æœ‰å¯¹åº”çš„é¡¹ã€‚å¦‚æ³¨é‡Šæ‰€è¯´ï¼Œåº”è¯¥æ˜¯APIä½¿ç”¨é”™è¯¯ä¸å»ç®¡ä»–ã€‚ POLLERRå’ŒROLLHUPåŸå°ä¸åŠ¨å¤åˆ¶äº†intOpsï¼Œä¹Ÿå°±æ˜¯ä¼šè§¦å‘æ‰€æœ‰æ³¨å†Œçš„äº‹ä»¶ã€‚ è¿™é‡Œè¿˜ç¿»åˆ°Nettyçš„ä¸€ä¸ªissuehttps://github.com/netty/netty/issues/924ã€‚ 123456789101112131415161718192021if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123; // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking // See https://github.com/netty/netty/issues/924 int ops = k.interestOps(); ops &amp;= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect();&#125;// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write ch.unsafe().forceFlush();&#125;// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead// to a spin loopif ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123; unsafe.read();&#125; nettyçš„OP_CONNECTå¤„ç†åœ¨ç¬¬ä¸€ä½ï¼Œå½“å¯¹æ–¹å‘é€Resetæ—¶ï¼Œé¦–å…ˆä¼šè¿›å…¥unsafe.finishConnect()ï¼Œè€Œè¿™é‡Œå¹¶æ²¡æœ‰å–æ¶ˆäº‹ä»¶ä¹Ÿæ²¡æœ‰å…³é—­è¿æ¥çš„é€»è¾‘ã€‚ æœ€åæ³¨æ„åˆ°ä¸Šé¢ä»£ç çš„æœ€åä¸€è¡Œï¼ŒJavaæŠŠINäº‹ä»¶åˆ†ç¦»æˆACCEPTå’ŒREADï¼Œä½†æ˜¯NettyåˆæŠŠACCEPTå’ŒREADç»Ÿä¸€èµ·æ¥ï¼ŒServerSocketçš„è¯»å¤„ç†å°±æ˜¯è°ƒç”¨Accept: 1234567891011121314151617181920protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123; SocketChannel ch = SocketUtils.accept(javaChannel()); try &#123; if (ch != null) &#123; buf.add(new NioSocketChannel(this, ch)); return 1; &#125; &#125; catch (Throwable t) &#123; logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, t); try &#123; ch.close(); &#125; catch (Throwable t2) &#123; logger.warn(&quot;Failed to close a socket.&quot;, t2); &#125; &#125; return 0;&#125; æ•´ä¸ªäº‹æƒ…çš„æ„Ÿè§‰å°±æ˜¯éƒ½æœ‰è‡ªå·±è¿™ä¹ˆåšçš„ç†ç”±ï¼Œä½†æ˜¯ç»„åˆèµ·æ¥å°±ååˆ†æ»‘ç¨½ã€‚","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Javaæ ‡å‡†åº“ä¸­ä¸€å¤„ä¸å¤ªåˆç†çš„åœ°æ–¹","slug":"generic-heap","date":"2020-08-05T20:44:34.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/08/05/generic-heap/","link":"","permalink":"https://ezksd.github.io/2020/08/05/generic-heap/","excerpt":"","text":"æ³›å‹ä¼—æ‰€å‘¨çŸ¥ï¼ŒJavaçš„æ³›å‹éå¸¸æ‹‰ç¨€ã€‚è™½ç„¶æˆ‘è®¤ä¸ºåœ¨è¡¨è¾¾èƒ½åŠ›å·®ä¸å¤šçš„æƒ…å†µä¸‹ï¼Œåˆ«çš„éƒ½å¯ä»¥å¿å¿ã€‚Javaçš„è¡¨è¾¾èƒ½åŠ›å·®åœ¨å“ªé‡Œå‘¢ï¼š ä¸èƒ½åˆ›å»ºæ³›å‹æ•°ç»„ å¯ä»¥ç”¨Object[]åŠ å¼ºåˆ¶è½¬å‹ï¼Œä¸æ­¤åŒæ—¶æ–¹æ³•è¿˜è¦åŠ ä¸Š@SuppressWarnings(â€œuncheckedâ€)ï¼Œä¸ç„¶ä¼šæœ‰ç¼–è¯‘æœŸè­¦å‘Šã€‚ ä¸èƒ½é€šè¿‡æ³›å‹åˆ›å»ºå¯¹è±¡ å¯ä»¥æŠŠClass&lt;T&gt;ä½œä¸ºå‚æ•°ï¼Œåœ¨å†…éƒ¨ç”¨åå°„è°ƒæ„é€ å‡½æ•°ã€‚è¿™ç§æƒ…å†µéå¸¸æ™®éï¼Œä½†åœ¨Java8æˆ–ä»¥ä¸Šç‰ˆæœ¬ä¸­å¹¶ä¸åˆé€‚ã€‚æˆ‘ä»¬å¯ä»¥æŠŠå‚æ•°Class&lt;T&gt;æ”¹ä¸ºSupplier&lt;T&gt;ï¼Œè®²ç©¶ä¸€ç‚¹å¯ä»¥å†™æˆSupplier&lt;? extends T&gt;ï¼Œç„¶åè°ƒç”¨çš„æ—¶å€™ä¼ å…¥æ„é€ å™¨æ–¹æ³•å¼•ç”¨ã€‚ï¼ˆç›®å‰è¿˜æƒ³ä¸å‡ºç‰¹åˆ«å¥½çš„ä¾‹å­å±•ç¤ºè¿™ä¸¤è€…çš„åŒºåˆ«ï¼Œæƒ³åˆ°å†è¡¥ï¼‰ 123456static &lt;E&gt; E construct(Supplier&lt;? extends E&gt; sup)&#123; return sup.get();&#125;public static void main(String[] args) &#123; String s = construct(String::new);&#125; ä¸¾ä¸€ä¸ªnettyçš„ä¾‹å­ï¼š 1234567891011121314Bootstrap b = new Bootstrap();b.group(group) .channel(NioSocketChannel.class) // çœ‹è¿™é‡Œ .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT)); &#125; p.addLast(new EchoClientHandler()); &#125; &#125;); è€Œchannelå‡½æ•°æ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼š 12345public B channel(Class&lt;? extends C&gt; channelClass) &#123; return channelFactory(new ReflectiveChannelFactory&lt;C&gt;( ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;) ));&#125; è¿™é‡ŒChannelFactoryç­‰ä»·äºSupplier&lt;T extends Channel&gt;ï¼Œ åªéœ€è¦ç”¨channelFactory(NioSocketChannel::new)å°±å¯ä»¥äº†ã€‚::newè¿˜æ¯”.classå°‘ä¸€ä¸ªå­—ç¬¦ï¼Œåœ¨java9ä»¥ä¸Šç‰ˆæœ¬åå°„å¯èƒ½ä¼šå‡ºç°å¾®å¦™çš„é—®é¢˜ï¼Œè€Œåå°„å”¯ä¸€çš„ä¼˜ç‚¹æ˜¯èƒ½è°ƒç”¨ç§æœ‰çš„æ„é€ å‡½æ•°ã€‚ ä¸æ”¯æŒåå˜é€†å˜ï¼Œæˆ–è€…è¯´ä»¥ä¸€ä¸ªéš¾çœ‹çš„æ–¹å¼æ”¯æŒéƒ¨åˆ†åå˜é€†å˜ æš‚æ—¶æ²¡æœ‰ç¬¬å›› å¯å˜æ€§(åå˜/é€†å˜)Javaçš„å¯å˜æ€§å’Œå…¶ä»–è¯­è¨€(æ¯”å¦‚Scala, C#)é‡Œæœ€å¤§çš„åŒºåˆ«åœ¨äºJavaçš„å¯å˜æ€§åœ¨ä½¿ç”¨çš„æ—¶å€™æ ‡æ˜(æ¯”å¦‚å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œä»£å…¥ç±»å‹å‚æ•°)ï¼Œè€Œå…¶ä»–è¯­è¨€åœ¨å®šä¹‰ç±»/æ¥å£/ç‰¹è´¨çš„æ—¶å€™æ ‡æ˜ã€‚ 1Collection&lt;? extends A&gt; collections = ...; 123class Collection[+A]&#123;&#125; é—®é¢˜æ ‡å‡†åº“é‡Œçš„PriorityQueue&lt;E&gt;ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„å †ï¼Œå®šä¹‰æ˜¯è¿™æ ·çš„ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; private final Comparator&lt;? super E&gt; comparator; public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null); &#125; public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null); &#125; public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator); &#125; public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125; //çœ‹è¿™é‡Œ private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] es) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = es[parent]; if (key.compareTo((T) e) &gt;= 0) break; es[k] = e; k = parent; &#125; es[k] = key; &#125; è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œå¯ä»¥æ‰‹åŠ¨æŒ‡å®šComparatorï¼Œå¦‚æœTæœ¬èº«æ˜¯Comparableçš„å­ç±»å‹çš„è¯ä¹Ÿå¯ä»¥ä¸ç”¨æŒ‡å®šï¼Œæ­¤æ—¶comparatorä¸ºç©ºï¼Œæ¯”è¾ƒçš„æ—¶å€™ä¼šå¼ºåˆ¶è½¬å‹ä¸ºComparableã€‚ä½†æ˜¯å¦‚æœè¿™ä¸ªæ—¶å€™æˆ‘ä¸å°å¿ƒåˆ›å»ºäº†ä¸€ä¸ªæ²¡æœ‰å®ç°Comparableçš„ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œç¼–è¯‘æœŸä¸ä¼šæœ‰ä»»ä½•é—®é¢˜ï¼Œè¿è¡Œçš„æ—¶å€™å°±ç‚¸äº†ã€‚ä¹Ÿå¤ªä¸å°å¿ƒäº†ä½†æ˜¯å…¶å®æ˜¯å¯ä»¥åœ¨ç¼–è¯‘æœŸé¿å…è¿™ç§æƒ…å†µï¼š 123456789101112131415161718192021public class Heap&lt;E&gt; &#123; Comparator&lt;? super E&gt; comp; E[] array; @SuppressWarnings(&quot;unchecked&quot;) private Heap(Comparator&lt;? super E&gt; comp, int size) &#123; this.comp = comp; this.array = (E[]) new Object[size]; &#125; static &lt;E extends Comparable&lt;? super E&gt;&gt; Heap&lt;E&gt; newHeap() &#123; return newHeap(Comparable::compareTo); &#125; static &lt;E&gt; Heap&lt;E&gt; newHeap(Comparator&lt;? super E&gt; comp) &#123; return newHeap(comp,16); &#125; static &lt;E&gt; Heap&lt;E&gt; newHeap(Comparator&lt;? super E&gt; comp, int size) &#123; return new Heap&lt;&gt;(comp,size); &#125;&#125; å½“ç„¶è¿™é‡Œæ˜¯é™æ€æ–¹æ³•ï¼Œå› ä¸ºç”¨æ„é€ å™¨çš„è¯è¡Œä¸é€šã€‚","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Java 14 ç‰¹æ€§ç®€ä»‹","slug":"java-14","date":"2020-06-23T10:00:00.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/06/23/java-14/","link":"","permalink":"https://ezksd.github.io/2020/06/23/java-14/","excerpt":"","text":"java 14å‡ºæ¥å·²ç»æœ‰ä¸€æ®µæ—¶é—´äº†ï¼Œç›¸æ¯”ä¹‹å‰çš„å°å¹…æ›´æ–°ï¼Œè¿™ä¸€æ¬¡çš„æ–°å¢è¯­æ³•ç‰¹æ€§è¿˜æ˜¯æ¯”è¾ƒå¤šçš„ã€‚è€Œä¸”å‰é¢çš„ä¼—å¤šç‰¹æ€§ï¼ŒåŒ…æ‹¬14ä¸­çš„éƒ¨åˆ†ç‰¹æ€§éƒ½æ˜¯ä¸ºæ¨¡å¼åŒ¹é…åšå‡†å¤‡ï¼ŒåŸºæœ¬ä¸Šå°±å·®ä¸´é—¨ä¸€è„šäº†ã€‚æœ¬æ–‡å°†ä»…å¯¹æ–°å¢è¯­æ³•ç‰¹æ€§åšä¸€ä¸ªç®€å•ä»‹ç»ã€‚ 305: Pattern Matching for instanceof (Preview)è¿™æ˜¯ä¸€ä¸ªpreviewç‰¹æ€§ï¼Œéœ€è¦ç¼–è¯‘çš„æ—¶å€™åŠ ä¸Š--enable-previewå‚æ•°ï¼ŒåŒæ—¶è¿˜è¦æŒ‡å®š--releaseæˆ–è€…--sourceï¼Œä»…ä½œå°é²œä½¿ç”¨ã€‚ è¿™ä¸ªç‰¹æ€§æœ¬èº«çš„ä½œç”¨æ˜¯ç®€åŒ–instance ofçš„ä½¿ç”¨ï¼Œå› ä¸ºå¦‚æœinstance ofä¸ºçœŸï¼Œé‚£ä¹ˆä¹‹åçš„å¼ºåˆ¶è½¬å‹å°±æ˜¾å¾—å¾ˆå¤šä½™ã€‚æ¯”å¦‚ï¼š 1234if (obj instanceof String) &#123; String s = (String) obj; // use s&#125; ç°åœ¨å¯ä»¥å†™æˆï¼š 12345if (obj instanceof String s) &#123; // can use s here&#125; else &#123; // can&#x27;t use s here&#125; æ³¨æ„åˆ°ï¼Œæ–°çš„è¯­æ³•instance ofç±»å‹ä¹‹åå¤šäº†ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¹Ÿæ˜¯å”¯ä¸€çš„åŒºåˆ«ã€‚è™½ç„¶ä»–çœ‹ä¸Šå»ä»ç„¶å»æœ‰ç‚¹å¤šä½™ï¼Œä¸ºä»€ä¹ˆä¸åœ¨å¯¹åº”çš„ä½œç”¨åŸŸå†…objçš„ç±»å‹ç›´æ¥å°±å½“æˆStringå‘¢ã€‚æˆ‘çŒœæµ‹æ˜¯è¿™ä¸ªç‰¹æ€§ä¸ºäº†å’Œåç»­çš„æ¨¡å¼åŒ¹é…çš„è§£æ„é£æ ¼ä¿æŒä¸€è‡´ï¼Œæ¯•ç«Ÿè¿™ä¸ªç‰¹æ€§æœ¬èº«å°±æ˜¯ä¸ºæ¨¡å¼åŒ¹é…é“ºè·¯çš„ã€‚ 359: Records (Preview)è¿™ä¾ç„¶æ˜¯ä¸€ä¸ªpreviewç‰¹æ€§ï¼Œå®ƒå¾ˆåƒcçš„ç»“æ„ä½“ï¼Œä½†å‡†ç¡®æ¥è®²å®ƒæ›´åƒscalaçš„case classã€‚åŠ ä¸ŠJEP 360: Sealed Classes (Preview)ä¹‹åï¼Œå°±ç­‰äºæ”¯æŒä»£æ•°æ•°æ®ç±»å‹äº†ï¼Œå½“ç„¶ç›®å‰ä¹Ÿå·®ä¸å¤šå¯ä»¥ç”¨äº†ï¼Œå·®åˆ«æ˜¯æ¨¡å¼åŒ¹é…çš„æ—¶å€™ç¼–è¯‘å™¨èƒ½å¦åˆ¤æ–­ä»£ç æœ‰æ²¡æœ‰æŠŠæ‰€æœ‰çš„å¯èƒ½æ€§å†™å…¨ã€‚æŠ›å¼€è¿™äº›ï¼ŒRecordå¯ä»¥è§†ä¸ºä¸€ä¸ªè¯­æ³•ç³–ï¼Œå› ä¸ºä»–ç¼–è¯‘ä¹‹åå¯ä»¥è¿˜åŸæˆä¸€ä¸ªç­‰ä»·çš„classã€‚åˆ©ç”¨è¿™ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å°‘å†™å¾ˆå¤šä»£ç ï¼Œå› ä¸ºrecordå¯ä»¥è‡ªåŠ¨ç”Ÿæˆï¼šæ„é€ å™¨ï¼Œgetæ–¹æ³•ï¼ŒtoStringï¼ŒhashCodeï¼Œequalsæ–¹æ³•ï¼Œæ³¨æ„ï¼šè¿™é‡Œå¹¶æ²¡æœ‰setæ–¹æ³•ï¼Œå› ä¸ºrecordé»˜è®¤æ˜¯ä¸å¯å˜çš„ã€‚è€Œä¸”recordå¯ä»¥å®ç°æ¥å£ï¼Œä½†æ˜¯ä¸èƒ½ç»§æ‰¿å…¶ä»–ç±»ï¼ŒåŒæ—¶é™¤æ­¤ä»¥å¤–å’Œä¸€ä¸ªæ™®é€šçš„classæ²¡æœ‰ä»€ä¹ˆå·®åˆ«ã€‚ 1record Point(int x, int y) &#123; &#125; è¯­æ³•å¦‚ä¸Šï¼Œå› ä¸ºrecordè¿˜èƒ½æ·»åŠ è‡ªå®šä¹‰æ„é€ å™¨å’Œå®ç°æ–¹æ³•ï¼Œä¸ºäº†ä¿æŒä¸€è‡´è¿˜æ˜¯ä¿ç•™äº†å¤§æ‹¬å·ï¼ˆè™½ç„¶çœ‹ä¸Šå»å¾ˆå¤šä½™ï¼‰ï¼ JEP 361: Switch Expressions (Standard)è¿™ä¸ªä¹‹å‰å°±æœ‰ï¼Œä¸è¿‡åœ¨java 14ä¸­ä¸å†æ˜¯previewç‰¹æ€§äº†ï¼Œç®€å•å°†ï¼Œswitchè¯­å¥æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒæ˜¯æœ‰å€¼çš„ï¼å½“ç„¶è¯­æ³•å’Œswitch statementæœ‰ä¸€äº›å·®åˆ«ï¼ 123456switch (day) &#123; case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6); case TUESDAY -&gt; System.out.println(7); case THURSDAY, SATURDAY -&gt; System.out.println(8); case WEDNESDAY -&gt; System.out.println(9);&#125; è¿™æ®µä»£ç å¹¶æ²¡æœ‰ä½“ç°å‡ºswitch expressionsæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¸switch statementçš„æœ€å¤§å·®åˆ«æ˜¯ä»–æ²¡æœ‰fall throughç‰¹æ€§ï¼Œä¸éœ€è¦åˆ°å¤„åŠ breakäº†ï¼ ç‹å æ›¾ç»è®²ï¼šè®¿é—®è€…æ¨¡å¼åªæ˜¯æ¨¡å¼åŒ¹é…ä¸‘é™‹çš„æ¨¡ä»¿(å¤§æ„)ï¼è§‚ç‚¹æ­£ç¡®ä¸å¦æš‚ä¸”ä¸è®ºï¼Œæ¨¡å¼åŒ¹é…å’Œè§‚å¯Ÿè€…æ¨¡å¼çš„ç¡®æœ‰å¾ˆå¤šå…±åŒä¹‹å¤„ï¼æ¯”å¦‚ä¸€ä¸ªè®¿é—®è€…æ¥å£çš„å®šä¹‰(ä»¥éå†äºŒå‰æ ‘ä¸ºä¾‹)ï¼š 1234public interface Visitor &#123; public void visit(Node n); public void visit(Leaf l);&#125; å’Œhaskellçš„æ¨¡å¼åŒ¹é…å®šä¹‰å¦‚å‡ºä¸€è¾™ 123visit :: Tree e -&gt; ()visit (Node n) = ...visit (Leaf f) = ... è™½ç„¶è¿™äº›è¯­æ³•ç¦»å®Œæ•´çš„æ¨¡å¼åŒ¹é…è¿˜å·®ä¸€è„šï¼Œä¸è¿‡å·²ç»å·®ä¸å¤šå¤Ÿäº†ï¼Œæ¥ä¸‹æ¥å°±ç”¨æ–°çš„è¯­æ³•å†™ä¸€ä¸ªç®€å•çš„è®¡ç®—å™¨ï¼ è®¡ç®—å™¨é¦–å…ˆæ˜¯tokençš„å®šä¹‰ã€‚scalaä¸­æœ‰ä¸case classå¯¹åº”çš„cass objectï¼Œä¹Ÿå°±æ˜¯å•ä¾‹çš„recordã€‚ä¸è¿‡javaç›®å‰è¿˜æ²¡æœ‰ï¼Œç”¨enumä»£æ›¿ï¼š 1234567891011interface Token &#123; &#125;record Number(int i) implements Token&#123; &#125;enum Operator implements Token&#123; ADD,MINUS,MULTIPLY,DIVIDED&#125;enum Bracket implements Token&#123; LEFT,RIGHT;&#125; ç”±äºjavaæ ‡å‡†åº“ä¸­æ²¡æœ‰tupleï¼Œå†åŠ ä¸€ä¸ªtupleï¼Œç”¨æ¥å½“å¤šè¿”å›å€¼ï¼ŒåŒæ—¶è¿”å›tokenå’Œæ‰€åœ¨çš„ä½ç½®ï¼ 1record Tuple&lt;A,B&gt;(A a,B b)&#123;&#125; ç„¶åæ˜¯parseréƒ¨åˆ†ï¼Œçœå»äº†tokenizer 123456789101112131415161718192021222324252627282930313233343536373839static Optional&lt;List&lt;Token&gt;&gt; parseAll(String s) &#123; var i = 0; var list = new LinkedList&lt;Token&gt;(); while (i &lt; s.length()) &#123; var r = parse(s, i); if (r.isPresent()) &#123; list.add(r.get().a()); i = r.get().b(); &#125; else &#123; return Optional.empty(); &#125; &#125; return Optional.of(list);&#125;static Optional&lt;Tuple&lt;Token, Integer&gt;&gt; parse(String s, int p) &#123; var c = s.charAt(p); return switch (c) &#123; case &#x27;(&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Bracket.LEFT, p + 1)); case &#x27;)&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Bracket.RIGHT, p + 1)); case &#x27;*&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.MULTIPLY, p + 1)); case &#x27;/&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.DIVIDED, p + 1)); case &#x27;+&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.ADD, p + 1)); case &#x27;-&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.MINUS, p + 1)); default -&gt; parseNumber(s, p); &#125;;&#125;static Optional&lt;Tuple&lt;Token, Integer&gt;&gt; parseNumber(String s, int p) &#123; int i = 0; if (!Character.isDigit(s.charAt(p)))&#123; return Optional.empty(); &#125; while (p &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(p))) &#123; i = i * 10 + (s.charAt(p++) - &#x27;0&#x27;); &#125; return Optional.of(new Tuple&lt;&gt;(new Number(i), p));&#125; æ¥ä¸‹æ¥æ˜¯è§£é‡Šéƒ¨åˆ†ï¼Œå·¦é€’å½’æ¶ˆé™¤å°±ä¸èµ˜è¿°äº†ï¼Œç®€å•è¯´ä¸‹æ–‡æ³•ï¼š 12345expr = term expr1expr1 = (+/-) term expr1 | Îµterm = digit | term1term1 = (*//) digit term1 | Îµdigit = æ•´æ•° | &#x27;(&#x27; expr &#x27;)&#x27; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static Optional&lt;Tuple&lt;Double,Integer&gt;&gt; expr(List&lt;Token&gt; list,int p)&#123; var term = term(list, p); return term.flatMap(x -&gt;&#123; var tuples = expr1(list, x.b()); return tuples.map(xs -&gt; &#123; double s = x.a(); for (var tuple : xs.a()) &#123; switch (tuple.a()) &#123; case ADD -&gt; s += tuple.b(); case MINUS -&gt; s -= tuple.b(); default -&gt; throw new UnsupportedOperationException(); &#125; &#125; return new Tuple&lt;&gt;(s, xs.b()); &#125;); &#125;); &#125; static Optional&lt;Tuple&lt;List&lt;Tuple&lt;Operator, Double&gt;&gt;, Integer&gt;&gt; expr1(List&lt;Token&gt; list, int p)&#123; var result = new LinkedList&lt;Tuple&lt;Operator,Double&gt;&gt;(); while (p &lt; list.size()) &#123; var token = list.get(p); var term = term(list, p + 1); if(term.isPresent() &amp;&amp; (token == Operator.ADD || token == Operator.MINUS))&#123; result.add(new Tuple&lt;&gt;((Operator)token, term.get().a())); p = p + 2; &#125;else &#123; break; &#125; &#125; return Optional.of(new Tuple&lt;&gt;(result, p)); &#125; static Optional&lt;Tuple&lt;Double,Integer&gt;&gt; term(List&lt;Token&gt; list,int p)&#123; var digit = digit(list, p); return digit.flatMap(x -&gt; &#123; var tuples = term1(list, x.b()); return tuples.map(xs -&gt; &#123; double s = x.a(); for (Tuple&lt;Operator, Double&gt; tuple : xs.a()) &#123; switch (tuple.a()) &#123; case MULTIPLY -&gt; s *= tuple.b(); case DIVIDED -&gt; s /= tuple.b(); default -&gt; throw new UnsupportedOperationException(); &#125; &#125; return new Tuple&lt;&gt;(s,xs.b()); &#125;); &#125;); &#125; static Optional&lt;Tuple&lt;List&lt;Tuple&lt;Operator,Double&gt;&gt;,Integer&gt;&gt; term1(List&lt;Token&gt; list,int p)&#123; var result = new LinkedList&lt;Tuple&lt;Operator,Double&gt;&gt;(); while (p &lt; list.size()) &#123; var token = list.get(p); var term = digit(list, p + 1); if(term.isPresent() &amp;&amp; (token == Operator.MULTIPLY || token == Operator.DIVIDED))&#123; result.add(new Tuple&lt;&gt;((Operator)token, term.get().a())); p = p + 2; &#125;else &#123; break; &#125; &#125; return Optional.of(new Tuple&lt;&gt;(result, p)); &#125; static Optional&lt;Tuple&lt;Double, Integer&gt;&gt; digit(List&lt;Token&gt; list, int p) &#123; if (p &lt; list.size())&#123; var t = list.get(p); if (t instanceof Number) return Optional.of(new Tuple&lt;&gt;(((double) ((Number) list.get(p)).i()), p + 1)); else if(t == Bracket.LEFT)&#123; return expr(list, p + 1).flatMap(x -&gt; &#123; if (x.b() &lt; list.size() &amp;&amp; list.get(x.b()) == Bracket.RIGHT) &#123; return Optional.of(new Tuple&lt;&gt;(x.a(), x.b() + 1)); &#125;else &#123; return Optional.empty(); &#125; &#125;); &#125; &#125; return Optional.empty(); &#125; æœ€åè¿”å›çš„æ˜¯å€¼å’Œå­—ç¬¦æ‰€åœ¨ä½ç½®çš„tupleï¼Œå†åŠ ä¸€ä¸ªåŒ…è£…å‡½æ•°å°±å®Œå·¥äº†ï¼š 12345static Optional&lt;Double&gt; caculate(List&lt;Token&gt; tokens) &#123; var list = new ArrayList&lt;Token&gt;(tokens.size()); list.addAll(tokens); return expr(list,0).map(Tuple::a);&#125; å®Œæ•´ä»£ç åœ¨è¿™é‡Œã€‚","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Rustçš„ç¼ºç‚¹","slug":"rust","date":"2019-06-02T19:17:15.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2019/06/02/rust/","link":"","permalink":"https://ezksd.github.io/2019/06/02/rust/","excerpt":"","text":"è¿™ä¸–ç•Œæœ‰å¤ªå¤šçš„ä¼ æ•™å£«äº†ï¼Œæ¯”å¦‚ä¸€éƒ¨åˆ†Haskellä¼ æ•™å£«ä¼šæ‹¿ä¸€ä¸ªä¸¤è¡Œçš„å¿«æ’ï¼Œä½†æ˜¯ä¸å‘Šè¯‰ä½ é‚£ä¸æ˜¯åŸåœ°æ’åºï¼Œè€Œç­‰ä»·çš„åŸåœ°æ’åºå¯èƒ½æ¯”javaè¿˜é•¿ã€‚ é‚£RustçœŸçš„æœ‰ä¼ æ•™å£«è¯´çš„é‚£ä¹ˆç¾å—ï¼Œæ˜¯å¦é—æ¼äº†ä»€ä¹ˆã€‚ traitä¸æ˜¯ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿä¸æ”¯æŒå­ç±»å‹å½“ç„¶ï¼Œè¿™å¯èƒ½æ˜¯è®¾è®¡éœ€è¦ï¼Œä½†è®©äººéš¾å—ä½†åœ°æ–¹ï¼Œæˆ‘å…ˆæŠŠä»–å½’ç±»ä¸ºç¼ºç‚¹ã€‚ 123fn compare(a: Ord,b: Ord) -&gt; bool&#123; a &lt; b&#125; 1234567error[E0038]: the trait `std::cmp::Ord` cannot be made into an object --&gt; src/main.rs:2:15 |2 | fn compare(a: Ord,b: Ord) -&gt; bool&#123; | ^^^ the trait `std::cmp::Ord` cannot be made into an object | = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses ä¸è¿‡ä½ å¯ä»¥ç”¨ç±»å‹æ¨å¯¼ï¼Œè¿™é‡Œè¦æ±‚è¯¥ç±»å‹å®ç°äº†Ord traitï¼Œ äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥ç”¨&lt;æ¥æ¯”è¾ƒäº†ã€‚ 123fn compare&lt;A:Ord&gt;(a: A,b: A) -&gt; bool&#123; a &lt; b&#125; è¿™ä¸å­ç±»å‹æœ‰æœ¬è´¨çš„åŒºåˆ«ï¼Œæ¯”å¦‚åœ¨è¿”å›å€¼ä½ç½®å°±æ²¡åŠæ³•è¿™ä¹ˆå†™äº†ã€‚è¿”å›å€¼åœ¨å‡½æ•°å†…éƒ¨å·²ç»ç»™å‡ºï¼Œæ¨å¯¼çš„æ—¶å€™å°±å¯¹ä¸ä¸Šäº†ã€‚ å†æ„›ä½ ï¼Œä¾ç„¶æ˜¯å…©å€‹äººï½ 123fn compare&lt;A:Ord&gt;() -&gt; A&#123; 1&#125; 12345678910error[E0308]: mismatched types --&gt; src/main.rs:3:5 |2 | fn compare&lt;A:Ord&gt;() -&gt; A&#123; | - expected `A` because of return type3 | 1 | ^ expected type parameter, found integer | = note: expected type `A` found type `&#123;integer&#125;` ä¸æ˜¯æ‰€æœ‰çš„å€¼éƒ½æœ‰ä¸€ä¸ªæ˜ç¡®çš„ç±»å‹ï¼Œæ¯”å¦‚é—­åŒ…ï¼Œè¿™ä¸ªæ—¶å€™å°±è¦å­˜åœ¨ç±»å‹ï¼š ä¸–ç•Œä¸Šæ²¡æœ‰ä¸¤ç‰‡ç›¸åŒçš„å¶å­ï¼ŒRusté‡Œä¹Ÿæ²¡æœ‰ä¸¤ä¸ªçš„é—­åŒ… 12345678fn counter() -&gt; impl Fn() -&gt; i32&#123; let mut i = 0; || &#123; let r = i; i = i + 1; r &#125;&#125; ä¸æ­¤åŒæ—¶å­˜åœ¨ç±»å‹æ˜¯ä¸€ä¸ªéå¸¸éš¾ç”¨çš„ä¸œè¥¿ï¼Œä»–å¯¹åº”å­˜åœ¨é‡è¯ï¼Œè€ŒèŒƒå‹å¯¹åº”å…¨ç§°é‡è¯ã€‚ å»¶æ—¶æ±‚å€¼1234trait Iterator&#123; type Item; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;&#125; å¬ä¸Šå»å¾ˆç¾ï¼Œä½†å‡è®¾ä»–ä¸åšæ‰€è°“çš„å»¶æ—¶æ±‚å€¼ï¼Œç”šè‡³éƒ½æ²¡æœ‰åŠæ³•æŠ½è±¡å‡ºæ¥ä¸€å¥—ä¸œè¥¿ã€‚ æ¯”å¦‚mapæ–¹æ³•å¹¶æ²¡æœ‰ç«‹åˆ»è½¬æ¢ï¼Œè€Œæ˜¯ç›´æ¥æŠŠåŸæ¥çš„Iteratorå’Œå‡½æ•°åŒ…åœ¨äº†ç»“æ„ä½“é‡Œï¼š 12345fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; whereSelf: Sized, F: FnMut(Self::Item) -&gt; B,&#123; Map::new(self, f)&#125; å‡å¦‚ä½ æƒ³æŠŠä»–çš„è¿”å›å€¼æ”¹æˆIterator&lt;Item=B&gt;æ˜¯ç¼–è¯‘ä¸è¿‡çš„ï¼Œå› ä¸ºtraitä¸æ˜¯ç±»å‹ã€‚è¿™é‡Œéœ€è¦ä¸€ä¸ªå…·ä½“çš„ç±»å‹ï¼Œæ¯”å¦‚ç»“æ„ä½“æˆ–è€…æšä¸¾ï¼Œäºæ˜¯ä½ ä¼šçœ‹åˆ°å¤§é‡è¿™æ ·çš„ä»£ç ï¼š 1234567fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, U::IntoIter&gt;fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U::IntoIter&gt;fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;fn enumerate(self) -&gt; Enumerate&lt;Self&gt; fn peekable(self) -&gt; Peekable&lt;Self&gt; æ¯å®šä¹‰ä¸€ä¸ªæ–°çš„æ–¹æ³•ï¼Œä½ å°±éœ€è¦å®šä¹‰ä¸€ä¸ªæ–°çš„ç»“æ„ä½“ï¼ˆå› ä¸ºä½ ä¸èƒ½åœ¨åŒä¸€ä¸ªç»“æ„ä½“ä¸Šå®ç°åŒä¸€ä¸ªtraitä¸¤æ¬¡ï¼‰ï¼Œç„¶åå†åœ¨ç»“æ„ä½“ä¸Šå®ç°traitçš„æ–¹æ³•ã€‚è¿™ç§ä»£ç é£æ ¼Javaç¨‹åºå‘˜ä¸€å®šå¾ˆç†Ÿæ‚‰ï¼Œæˆ‘æŠŠä»–ç§°ä¸ºå®åå†…éƒ¨ç±»ã€‚å¦‚æœæ¯”Iteratorå®˜æ–¹å®ç°çš„ä»£ç é•¿åº¦ï¼ŒRustè‚¯å®šæ˜¯é¦–å±ˆä¸€æŒ‡çš„ã€‚ å¦‚æœåªæ˜¯ä»£ç é•¿å€’ä¸æ˜¯å¾ˆå¤§çš„é—®é¢˜ï¼Œæ¯•ç«Ÿæˆ‘æ˜¯ä¸€åJavaç¨‹åºå‘˜ã€‚ å†çœ‹ä¸€ä¸ªå…·ä½“ä¸€ç‚¹çš„é—®é¢˜ï¼š 12345fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt;where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -&gt; U,&#123; FlatMap::new(self, f)&#125; Fï¼ˆè¿™é‡Œä»£è¡¨ä¸€ä¸ªå‡½æ•°ï¼‰çš„è¿”å›å€¼ç±»å‹Uæ˜¯æ ¹æ®ç±»å‹æ¨å¯¼æ¥çš„ï¼Œè¿™å°±é€ æˆä¸€ä¸ªé—®é¢˜ï¼Œå‡å¦‚å‡½æ•°ä¸­æœ‰if elseæˆ–è€…æ¨¡å¼åŒ¹é…è¿™æ ·çš„åˆ†æ”¯ï¼Œä¸¤ä¸ªåˆ†æ”¯çš„ç±»å‹ä¼šå¯¹ä¸ä¸Šã€‚æ³¨æ„è¿™é‡Œå¦‚æœä¸ç”¨returnï¼Œifè¡¨è¾¾å¼çš„ç±»å‹å°±å·²ç»å¯¹ä¸ä¸Šäº†ï¼ˆåœ¨Rustä¸­if elseæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå’ŒScalaç±»ä¼¼ï¼‰ã€‚ 1234567let j = (1..9).flat_map(|x|&#123; if (x % 2) == 0 &#123; return empty(); &#125;else&#123; return vec![x].iter(); &#125;&#125;).collect(); 12345678error[E0308]: mismatched types --&gt; src/main.rs:8:16 |8 | return vec![x].iter(); | ^^^^^^^^^^^^^^ expected struct `std::iter::Empty`, found struct `std::slice::Iter` | = note: expected type `std::iter::Empty&lt;_&gt;` found type `std::slice::Iter&lt;&#x27;_, &#123;integer&#125;&gt;` å‡å¦‚ä½ çš„ä»£ç é‡Œå‡ºç°äº†åˆ†æ”¯ï¼Œå…¶ä¸­ä¸€ä¸ªç”¨çš„map,å¦å¤–ä¸€ä¸ªç”¨çš„filter,é‚£ä»–ç±»å‹æ˜¯å¯¹ä¸ä¸Šçš„ï¼Œç”šè‡³äºè¯´éƒ½æ˜¯map,é—­åŒ…çš„ç±»å‹ä¹Ÿå¯¹ä¸ä¸Šï¼ˆé—­åŒ…æ˜¯Mapçš„ç±»å‹å‚æ•°ï¼‰ã€‚ å¦‚æœä½ å¬è¯´Rustæ”¯æŒtype classï¼Œæƒ³æ¥æç‚¹å‡½æ•°å¼ï¼Œä½ æ˜¯å¦æé”™äº†ä»€ä¹ˆï¼Ÿ é¢å‘å¯¹è±¡ ä½ ä¸è¦æŠŠFPé‚£å¥—ä¸œè¥¿æè¿‡æ¥ï¼ŒåŒæ—¶ä¹Ÿä¸è¦OOPé‚£å¥—ä¸œè¥¿æè¿‡æ¥ï¼ŒRustå°±æ˜¯Rustã€‚ Rustå¯ä»¥ç”¨trait objectæ¥è¡¨è¾¾å¤šæ€ï¼Œä½†æ˜¯ç¼–è¯‘å™¨éœ€è¦åœ¨ç¼–è¯‘æœŸçŸ¥é“å‡½æ•°çš„å‚æ•°ã€å±€éƒ¨å˜é‡çš„å¤§å°ï¼Œæ‰€ä»¥è¿™é‡Œå¿…é¡»å¥—ä¸Šä¸€ä¸ªå¼•ç”¨æˆ–è€…Boxã€‚è€Œä¸”ç¼–è¯‘å™¨å¯¹trait objectæœ‰é¢å¤–çš„é™åˆ¶ï¼š Object Safety Is Required for Trait ObjectsYou can only make object-safe traits into trait objects. Some complex rules govern all the properties that make a trait object safe, but in practice, only two rules are relevant. A trait is object safe if all the methods defined in the trait have the following properties: The return type isnâ€™t Self. There are no generic type parameters. https://doc.rust-lang.org/book/ch17-02-trait-objects.html æ‰€æœ‰çš„æ–¹æ³•éƒ½ä¸èƒ½æœ‰æ³›å‹å‚æ•°ï¼Œé›¶æˆæœ¬æŠ½è±¡ã€‚ä¸è¿‡åœ¨è€ä¸€ç‚¹çš„æ–‡æ¡£é‡Œæœ‰å¦å¤–ä¸€æ¡ï¼Œè¿™ä¸€ç‚¹æˆ‘ä¹Ÿè®¤ä¸ºéå¸¸å‘çˆ¹ï¼ŒRustçš„æ–‡æ¡£æ•£è½åœ¨ä¸–ç•Œçš„å„ä¸ªè§’è½é‡Œã€‚ ä½ æ¸´æœ›åŠ›é‡å—ï¼Ÿ https://doc.rust-lang.org/book/title-page.html https://doc.rust-lang.org/edition-guide/rust-2018/index.html https://doc.rust-lang.org/1.19.0/book/first-edition/README.html åœ¨è€ç‰ˆçš„Rust Booké‡Œé¢å…³äºobject safetyæœ‰æ›´è¯¦ç»†çš„æè¿°ï¼š The error says that Clone is not â€˜object-safeâ€™. Only traits that are object-safe can be made into trait objects. A trait is object-safe if both of these are true: the trait does not require that Self: Sized all of its methods are object-safe So what makes a method object-safe? Each method must require that Self: Sized or all of the following: must not have any type parameters must not use Self Each method must require that Self: Sized or all of the followingâ€¦ æ–°ç‰ˆä¸ä»…æŠŠè¿™å¥è¯åˆ äº†ï¼Œæˆ‘ä¸çŸ¥é“æ˜¯æ€ä¹ˆæƒ³çš„ã€‚è¿™é‡Œå¯ä»¥ç†è§£ä¸ºåŠ äº†Self: Sized å°±å¯ä»¥ç»•è¿‡è¿™ä¸ªé™åˆ¶ï¼Œä¸æ­¤åŒæ—¶trait objectå°±ä¸èƒ½å†è°ƒç”¨è¿™ä¸ªæ–¹æ³•äº†ï¼Œæ¬²ç»ƒæ­¤åŠŸï¼Œå¿…å…ˆè‡ªå®«ã€‚ ä¾æ®è¿™ä¸€æ¡ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·æ¥å®šä¹‰Iteratorã€‚ 1234567trait Iterator&lt;E&gt;&#123; fn next(&amp;mut self) -&gt; E; fn flat_map&lt;B,F&gt;(self,f: F) -&gt; FlatMap&lt;Self,F&gt; where Self: Sized,F: Fn(E) -&gt; Box&lt;dyn Iterator&lt;B&gt;&gt;&#123; Map(self,f) &#125; &#125; ç¼ºç‚¹å°±æ˜¯ä½ éœ€è¦åœ¨å„ç§åœ°æ–¹å¥—Boxã€‚ å¼•ç”¨ å”å”ï¼Œå”å”ï¼Œå¬è¯´ä½ ä»¬è¿™ä¸ªè¯­è¨€å†™ä¸äº†é“¾è¡¨æ˜¯å—ï¼Ÿ Rustçš„å¼•ç”¨è§„åˆ™å¾ˆç®€å•ï¼šå¯å˜å¼•ç”¨å¯ä»¥åŒæ—¶å­˜åœ¨å¤šä¸ªï¼Œä¸å¯ä»¥å¼•ç”¨åŒæ—¶åªèƒ½å­˜åœ¨ä¸€ä¸ªï¼Œè€Œå¯å˜å¼•ç”¨å­˜åœ¨çš„æ—¶å€™ä¸èƒ½åˆ›å»ºä¸å¯å˜å¼•ç”¨ã€‚ å¸¸è§çš„é“¾è¡¨nextæ˜¯ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼ŒtailæŒ‡é’ˆä¹Ÿæ˜¯å¯å˜çš„ï¼Œä»–ä»¬åŒæ—¶æŒ‡å‘é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ˜¯Rustç»•ä¸è¿‡å»çš„åã€‚ è§„åˆ™ç®€å•ï¼Œä¸ä»£è¡¨ä»–ç”¨èµ·æ¥å®¹æ˜“ã€‚ä½ å¯ä»¥çœ‹åˆ°è¿™ä¸ªè§„åˆ™ï¼Œå°±é©¬ä¸Šæƒ³åˆ°Rustä¸ç”¨unsafeæ— æ³•å®ç°é“¾è¡¨ï¼Œç„¶åäº«å—ä¸€ä¸ªå‘¨æœ«è€Œä¸æ˜¯å’Œç¼–è¯‘å™¨æ­»ç£•å—ï¼Ÿ ç”Ÿå‘½å‘¨æœŸ ç‹å ï¼šrustæ‰€è°“çš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯æŠŠå¼•ç”¨è®¡æ•°é™åˆ¶ä¸º1ï¼Œé‚£å¤„ç†èµ·æ¥å½“ç„¶ç®€å•äº†ã€‚ ä¸å¾—ä¸ä½©æœç‹å çš„æ•é”ï¼Œé‚£ä¹ˆè¿™å¥è¯è¦å¦‚ä½•ç†è§£å‘¢ï¼Ÿå› ä¸ºçœ‹ä¸Šå»rustå…è®¸å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚ è¿™ä¹Ÿæ˜¯ç”Ÿå‘½å‘¨æœŸçš„è®¾è®¡ç†å¿µï¼Œå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸè¢«åŒ…å«åœ¨å€¼çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œæ‰€ä»¥ä»–å¯ä»¥ç›´æ¥å¿½ç•¥ï¼Œç”±æ‰€æœ‰è€…è´Ÿè´£é‡Šæ”¾ï¼Œè€Œæ‰€æœ‰è€…å°±æ˜¯é‚£ä¸ª1ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä½ æƒ³åœ¨çº¿ç¨‹ä¹‹é—´ä¼ å¼•ç”¨é€šå¸¸æ˜¯ä¸€ä¸ªé”™è¯¯çš„é€‰æ‹©ã€‚ è€Œå¯å˜å¼•ç”¨çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œå‡å¦‚æŠŠå¼•ç”¨æŒ‡å‘å¦å¤–ä¸€ä¸ªå€¼ï¼Œä»–éœ€è¦é‡Šæ”¾å‰ä¸€ä¸ªå€¼ã€‚ è¿™éƒ½ä¸çŸ¥é“ï¼Ÿå†å»çœ‹çœ‹TRPLå§ï¼Œéƒ½åœ¨é‡Œé¢ã€‚ TRPLè¯´åˆ°è¿™é‡Œå°±ä¸å¾—ä¸æThe Rust Programming Languageï¼ŒRustå¹ä»¬æŠŠä»–ç®€ç§°ä¸ºTRPLä»¥ç¤ºå°Šæ•¬ã€‚ä½ å¿…é¡»çŸ¥é“å®ƒï¼ŒåŒæ—¶ä¹Ÿå¿…é¡»çŸ¥é“è¿™ä¸ªç¼©å†™ã€‚ é‚£ä¹ˆTRPLï¼Œæœ‰æ²¡æœ‰é‚£ä¹ˆè¯¦ç»†ï¼Ÿæ˜¾ç„¶æ˜¯æ²¡æœ‰çš„ï¼Œé¦–å…ˆä»–ç›¸å¯¹äºè€çš„æ–‡æ¡£åšè¿‡ä¸€å®šçš„åˆ å‡ï¼Œæ¯”å¦‚ä¸Šé¢æåˆ°çš„trait objectã€‚é‚£å›åˆ°æ­£é¢˜ï¼Œæˆ‘è®¤ä¸ºè¿™ç¯‡æ–‡æ¡£æ¼æ‰äº†ä¸€ä¸ªç›¸å½“é‡è¦çš„ä¸œè¥¿å°±æ˜¯std::mem::replaceï¼ŒOptioné‡ŒæŠŠä»–åŒ…è£…æˆtakeã€‚ä»–çš„ä½œç”¨æ˜¯æŠŠæ—§çš„å€¼å–å‡ºæ¥ï¼ŒåŒæ—¶ç»™ä¸€ä¸ªæ–°å€¼ã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¯¹åŸæ¥çš„å€¼éšæ„æ“ä½œäº†ã€‚æˆ‘è®¤ä¸ºåœ¨ä½ çŸ¥é“è¿™ä¸ªä¸œè¥¿ä¹‹å‰ï¼Œä½ å¯èƒ½è‡³å°‘ä¼šæµªè´¹ä¸€ä¸ªæ˜ŸæœŸå°è¯•å»å¯¹å¯å˜å¼•ç”¨åšæ¨¡å¼åŒ¹é…ï¼Œç›´åˆ°ä½ çŸ¥é“æœ‰è¿™ä¸ªä¸œè¥¿ï¼Œæˆ–è€…ç²¾é€šunsafeã€‚ æ¯”å¦‚ï¼Œå‡å¦‚æˆ‘æƒ³æŠŠæ ˆé¡¶å–å‡ºæ¥ï¼Œç„¶åå‘åæŒªä¸€ä½ï¼Œå¯èƒ½ä¼šè¿™ä¹ˆå®ç°ã€‚ 1234567891011121314151617181920enum Stack&lt;E&gt; &#123; More(E,Box&lt;Stack&lt;E&gt;&gt;), Less&#125;impl &lt;E&gt; Stack&lt;E&gt; &#123; fn new() -&gt; Stack&lt;E&gt;&#123; Stack::Less &#125; fn pop(&amp;mut self) -&gt; Option&lt;E&gt;&#123; match self &#123; Stack::More(item,next) =&gt; &#123; *self = **next; Some(*item) &#125;, Stack::Less =&gt; None &#125; &#125;&#125; é‚£ä¹ˆä½ æ˜¾ç„¶çŠ¯äº†é”™è¯¯ï¼Œselfå¯å˜å¼•ç”¨å­˜åœ¨çš„åŒæ—¶ï¼Œæ¨¡å¼åŒ¹é…ä¼šåˆ›å»ºæ–°çš„å¼•ç”¨ã€‚é‚£æœ‰äº†replaceï¼Œå°±å¯ä»¥è¿™æ ·å†™ã€‚ 12345678910fn pop(&amp;mut self) -&gt; Option&lt;E&gt;&#123; let pre = std::mem::replace(self, Stack::Less); match pre &#123; Stack::More(item,next) =&gt; &#123; *self = *next; Some(item) &#125;, Stack::Less =&gt; None &#125;&#125; ä½†æ˜¯è¿™æ˜¾ç„¶ä¸å¤Ÿé›¶æˆæœ¬æŠ½è±¡ï¼Œå› ä¸ºLessæ˜¯ä¸€ä¸ªåƒåœ¾å€¼ï¼Œéšåå°±ä¼šè¢«é‡Šæ”¾æ‰ã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥ç”¨unsafeã€‚ 123456789fn pop(&amp;mut self) -&gt; Option&lt;E&gt;&#123; match unsafe&#123;std::ptr::read(self)&#125; &#123; Stack::More(item,next) =&gt; &#123; unsafe&#123;std::ptr::write(self, *next)&#125; Some(item) &#125;, Stack::Less =&gt; None &#125;&#125; ä»€ä¹ˆï¼Œç«Ÿç„¶æœ‰äººåœ¨ç”¨unsafe? unsafe è­¦å¯Ÿï¼Œå‡ºè­¦ğŸ‘®â€â™€ï¸ï¼ å­¦ä¹ æˆæœ¬ å¾ˆå¤šäººä»¥ä¸ºRustå­¦ä¹ æˆæœ¬å¾ˆé«˜ï¼Œä»–åªä¸è¿‡æŠŠå¤æ‚çš„éƒ¨åˆ†éƒ½æš´éœ²å‡ºæ¥äº†ã€‚ ä¸ï¼ŒRustçš„å­¦ä¹ æˆæœ¬æ¯”ä½ æƒ³è±¡çš„è¿˜è¦é«˜ã€‚ä¸ä»…ä»…æ˜¯å­¦ä¹ è¯­æ³•ï¼Œè€Œæ˜¯èŠ±å¤§é‡ä½†æ—¶é—´æ€»ç»“åœ¨è¿™ä¸€å¥—é™åˆ¶ä¹‹ä¸‹è¯¥å¦‚ä½•å†™ä»£ç ã€‚æ­£å¦‚åŒå­¦ä¹ å¦‚ä½•æˆ´ç€é•£é“è·³èˆğŸ’ƒğŸ’ƒğŸ’ƒã€‚ é‚£ä¹ˆRustå€¼å¾—å—ï¼Ÿ","categories":[{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"}],"tags":[]},{"title":"è‡ªå®šä¹‰Zshä¸»é¢˜","slug":"custom-zsh-theme","date":"2019-05-06T23:45:44.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2019/05/06/custom-zsh-theme/","link":"","permalink":"https://ezksd.github.io/2019/05/06/custom-zsh-theme/","excerpt":"","text":"ä¸€ç›´åœ¨ç”¨zshçš„ä¸»é¢˜ysã€‚ä¸€ç›´æœ‰ä¸€ä¸ªå¾ˆçƒ¦çš„é—®é¢˜ï¼Œåˆšè¿›å…¥shellçš„æ—¶å€™æœ€ä¸Šé¢æœ‰ä¸€ä¸ªç©ºè¡Œçœ‹èµ·æ¥ååˆ†éš¾å—ã€‚ä»Šå¤©æƒ³èµ·æ¥è§£å†³äº†ä¸€ä¸‹ï¼Œå‘ç°å¹¶ä¸å›°éš¾ã€‚ zshçš„ä¸»é¢˜å°±æ˜¯ä¸€ä¸ªshellæ–‡ä»¶ï¼Œä¿®æ”¹å˜é‡PROMTå°±å¥½äº†ï¼Œè€Œysè¿™ä¸ªä¸»é¢˜ys.zsh-theme 123456789101112PROMPT=&quot;%&#123;$terminfo[bold]$fg[blue]%&#125;#%&#123;$reset_color%&#125; \\%(#,%&#123;$bg[yellow]%&#125;%&#123;$fg[black]%&#125;%n%&#123;$reset_color%&#125;,%&#123;$fg[cyan]%&#125;%n) \\%&#123;$fg[white]%&#125;@ \\%&#123;$fg[green]%&#125;%m \\%&#123;$fg[white]%&#125;in \\%&#123;$terminfo[bold]$fg[yellow]%&#125;%~%&#123;$reset_color%&#125;\\$&#123;hg_info&#125;\\$&#123;git_info&#125;\\ \\%&#123;$fg[white]%&#125;[%*] $exit_code%&#123;$terminfo[bold]$fg[red]%&#125;$ %&#123;$reset_color%&#125;&quot; åœ¨å¼€å¤´çš„æ—¶å€™å°±åŠ äº†ä¸€ä¸ªæ¢è¡Œï¼ŒæŠŠä»–å»æ‰å‘½ä»¤ä¹‹é—´åˆå¤ªç´§å‡‘äº†ã€‚è€ŒPROMTæ˜¯ä¸€ä¸ªå˜é‡ï¼Œèµ‹å€¼æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œåœ¨é‡Œé¢æ’ä¸€ä¸ªå¸¦çŠ¶æ€çš„å‡½æ•°åˆè¡Œä¸é€šã€‚ å¥½åœ¨æ–‡æ¡£é‡Œæœ‰ä¸€ä¸ªå‡½æ•°precmdï¼Œæ¥ä¸‹æ¥å°±å¾ˆç®€å•äº†ï¼ŒæŠŠè¿™ä¸ªæ’å…¥åˆ°è¦ä¿®æ”¹çš„ä¸»é¢˜ï¼Œå†æŠŠPROMPTå†æŠŠå‰é¢çš„æ¢è¡Œåˆ æ‰å°±å¥½äº†ã€‚ 12345678local prompt_prefix_flag=falsefunction precmd()&#123; if $prompt_prefix_flag; then echo &quot;&quot; else prompt_prefix_flag=true fi&#125;","categories":[{"name":"shell","slug":"shell","permalink":"https://ezksd.github.io/categories/shell/"}],"tags":[]},{"title":"Rustå®ç°å‡½æ•°å¼åˆ—è¡¨","slug":"rust-functional-list","date":"2019-03-27T15:49:18.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2019/03/27/rust-functional-list/","link":"","permalink":"https://ezksd.github.io/2019/03/27/rust-functional-list/","excerpt":"","text":"æœ¬æ–‡æœ‰å‚è€ƒï¼ˆLearn Rust With Entirely Too Many Linked Lists)[https://rust-unofficial.github.io/too-many-lists/index.html]ï¼Œä½†åŸæ–‡ä¸­è·³è¿‡äº†å¾ˆå¤šéš¾å¤„ç†çš„æƒ…å†µï¼Œæ¯”å¦‚ç”¨Optionä»£æ›¿ä»£æ•°æ•°æ®ç±»å‹ï¼Œé“¾è¡¨å’ŒèŠ‚ç‚¹åˆ†å¼€å®šä¹‰ï¼Œæ˜¾ç„¶è¿™æ˜¾ç„¶å¾ˆä¸å‡½æ•°å¼ã€‚ Rustå’ŒHaskelléå¸¸ç›¸ä¼¼ï¼Œæ¯”å¦‚æœ‰ADTã€æ¨¡å¼åŒ¹é…ï¼Œtrait/implå’Œclass/instanceå‡ ä¹æ˜¯ä¸€æ ·çš„ã€‚åˆ—è¡¨æ˜¯å‡½æ•°å¼è¯­è¨€ä¸­æœ€å¸¸ç”¨çš„æ•°æ®ç»“æ„ï¼Œä¸‹é¢å°è¯•åœ¨Rustä¸­å®ç°ä»–ã€‚ é¦–å…ˆåœ¨Haskellä¸­Listå¤§æ¦‚æ˜¯è¿™æ ·ï¼š 1data List a = Cons a (List a) | Nil ç¿»è¯‘æˆRustï¼š 1234enum List&lt;T&gt;&#123; Cons(T,List&lt;T&gt;), Nil&#125; 12345678error[E0072]: recursive type `List` has infinite size --&gt; src/lib.rs:6:1 |6 | enum List&lt;T&gt;&#123; | ^^^^^^^^^^^^ recursive type has infinite size7 | Cons(T,List&lt;T&gt;), | ------- recursive without indirection | Rustéœ€è¦åœ¨ç¼–è¯‘æœŸçŸ¥é“çŸ¥é“ç»“æ„ä½“/æšä¸¾çš„å¤§å°ï¼Œè¿™é‡Œæ˜¯é€’å½’çš„æ•°æ®ç»“æ„ï¼Œè€Œå¼•ç”¨æˆ–æ˜¯æŒ‡é’ˆå¤§å°æ˜¯å›ºå®šçš„ã€‚æ¶‰åŠåˆ°å¼•ç”¨å°±å¿…é¡»åŠ ä¸Šlifetimeï¼Œç„¶åå®ƒå°±å˜æˆäº†è¿™æ ·ã€‚ 1234enum List&lt;&#x27;a,T&gt;&#123; Cons(T,&amp;&#x27;a List&lt;&#x27;a,T&gt;), Nil&#125; æ ˆä¸Šå¼•ç”¨å¯èƒ½ä¼šå‡ºç°æ‚¬æŒ‚æŒ‡é’ˆçš„é—®é¢˜ã€‚ cannot return value referencing temporary valuereturns a value referencing data owned by the current function Box A pointer type for heap allocation.Box&lt;T&gt;, casually referred to as a â€˜boxâ€™, provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope. Boxæ˜¯åœ¨å †ä¸Šåˆ†é…çš„ã€‚ 1234567891011121314enum List&lt;T&gt; &#123; Cons(T, Box&lt;List&lt;T&gt;&gt;), Nil,&#125;impl List&lt;u32&gt; &#123; fn range(l: i32, h: i32) -&gt; List&lt;i32&gt; &#123; if l &lt; h &#123; List::Cons(l, Box::new(List::range(l + 1, h))) &#125; else &#123; List::Nil &#125; &#125;&#125; è¿­ä»£å™¨Iteratoréœ€è¦å®ç°çš„æ–¹æ³•ç­¾å: 1fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; å¯¹åº”ä¸åŒç±»å‹çš„å…ƒç´ ï¼ˆSelf::Item)ï¼Œä½†ç»“æ„ä½“æœ¬èº«è¿˜æ˜¯å¿…è¦ï¼Œå› ä¸ºéœ€è¦ä¿å­˜ä¸­é—´éå†çš„ä½ç½®ã€‚ T -&gt; IntoIter &amp;T -&gt; Iter &amp;mut T -&gt; IterMut å…ˆä»IntoIterå¼€å§‹ï¼Œåˆæ­¥å®ç°ï¼š 123456789101112131415struct IntoIter&lt;T&gt;(List&lt;T&gt;);impl &lt;T&gt; Iterator for IntoIter&lt;T&gt;&#123; type Item = T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match self.0 &#123; List::Cons(item,rest) =&gt; &#123; self.0 = *rest; Some(item) &#125; List::Nil =&gt; None &#125; &#125;&#125; 1234567891011error[E0507]: cannot move out of `self.0.1` which is behind a mutable reference --&gt; src/main.rs:21:15 |21 | match self.0 &#123; | ^^^^^^ help: consider borrowing here: `&amp;self.0`22 | List::Cons(item,rest) =&gt; &#123; | ---- | | | data moved here | move occurs because `rest` has type `std::boxed::Box&lt;List&lt;T&gt;&gt;`, which does not implement the `Copy` trait ^^^^ ^^^^ List,Boxå‡æ²¡æœ‰å®ç°Copyï¼Œæ‰€ä»¥å‡ºç°äº†moveï¼Œä½†æ˜¯å¼•ç”¨æ²¡æœ‰æ‰€æœ‰æƒã€‚ std::mem::replacehttps://doc.rust-lang.org/std/mem/fn.replace.html 12pub fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T// Moves src into the referenced dest, returning the previous dest value.Neither value is dropped. å…ˆå¡ä¸€ä¸ªList::Nilè¿›å»æŠŠæ—§å€¼æ¢å‡ºæ¥ï¼Œè¿™æ ·å°±è·å¾—äº†æ—§å€¼çš„æ‰€æœ‰æƒã€‚Optionçš„takeæ–¹æ³•å°±æ˜¯replaceçš„åŒ…è£…ã€‚ 12345678910111213impl &lt;T&gt; Iterator for IntoIter&lt;T&gt;&#123; type Item = T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match std::mem::replace(&amp;mut self.0,List::Nil) &#123; List::Cons(item,rest) =&gt; &#123; self.0 = *rest; Some(item) &#125; List::Nil =&gt; None &#125; &#125;&#125; Iterï¼ˆä¹Ÿå°±æ˜¯Itemç±»å‹ä¸º&amp;Tï¼‰æ¯”è¾ƒé¡ºç•…ï¼Œå› ä¸ºæœ‰å¼•ç”¨åŠ ä¸Šäº†ç”Ÿå‘½å‘¨æœŸï¼Œè¿”å›å€¼å’Œåˆ—è¡¨ç”Ÿå‘½å‘¨æœŸä¸€è‡´ã€‚ 12345678910111213141516struct Iter&lt;&#x27;a,T&gt;(&amp;&#x27;a List&lt;T&gt;);impl &lt;&#x27;a,T&gt; Iterator for Iter&lt;&#x27;a,T&gt;&#123; type Item = &amp;&#x27;a T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match self.0 &#123; List::Cons(item,rest) =&gt; &#123; self.0 = rest; Some(item) &#125; List::Nil =&gt; None &#125; &#125;&#125; ä½†æ˜¯å¯¹äºå…ƒç´ ç±»å‹ä¸º&amp;mut Tçš„è¿­ä»£å™¨åˆæœ‰æ–°çš„é—®é¢˜ã€‚ï¼ˆåƒç´ çº§æ‹·è´ä¸Šè¿°ä»£ç ï¼Œå°±ä¸è´´äº†ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162error[E0495]: cannot infer an appropriate lifetime for pattern due to conflicting requirements --&gt; src/main.rs:54:24 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^ |note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 52:5... --&gt; src/main.rs:52:5 |52 | fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^note: ...so that reference does not outlive borrowed content --&gt; src/main.rs:54:24 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^note: but, the lifetime must be valid for the lifetime `&#x27;a` as defined on the impl at 49:6... --&gt; src/main.rs:49:6 |49 | impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; | ^^note: ...so that the types are compatible --&gt; src/main.rs:52:46 |52 | fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; | ______________________________________________^53 | | match self.0 &#123;54 | | List::Cons(item,rest) =&gt;&#123;55 | | self.0 = rest.as_mut();... |63 | | &#125;64 | | &#125; | |_____^ = note: expected `Iterator` found `Iterator`error[E0495]: cannot infer an appropriate lifetime for pattern due to conflicting requirements --&gt; src/main.rs:54:29 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^ |note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 52:5... --&gt; src/main.rs:52:5 |52 | fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^note: ...so that reference does not outlive borrowed content --&gt; src/main.rs:54:29 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^note: but, the lifetime must be valid for the lifetime `&#x27;a` as defined on the impl at 49:6... --&gt; src/main.rs:49:6 |49 | impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; | ^^note: ...so that reference does not outlive borrowed content --&gt; src/main.rs:55:26 |55 | self.0 = rest.as_mut(); | ^^^^^^^^^^^^^ è¿™é‡Œself.0åˆ†è£‚æˆäº†ä¸¤ä¸ªä¸äº¤å‰çš„å¯å˜å¼•ç”¨ï¼ˆè¿™æ˜¯åˆæ³•çš„ï¼‰ï¼Œä½†æ˜¯åç»­self.0è¿˜ä¾ç„¶æŒæœ‰selfçš„å¯å˜å¼•ç”¨ï¼Œå› æ­¤å¤šä¸ªå¯å˜å¼•ç”¨å†²çªã€‚ä½†æŠ¥çš„æ˜¯ç”Ÿå‘½å‘¨æœŸçš„é”™ğŸ˜…ã€‚ è¿™ä¸€æ¬¡éœ€è¦æ›¿æ¢çš„æ˜¯å¼•ç”¨ï¼Œå› æ­¤éœ€è¦åˆ›å»ºä¸€ä¸ªç©ºæŒ‡é’ˆï¼Œå¼•ç”¨å’ŒæŒ‡é’ˆä½†åŒºåˆ«åœ¨äºï¼Œå¼•ç”¨æ˜¯åˆæ³•çš„ï¼Œä½†æŒ‡é’ˆå¯èƒ½æ˜¯éæ³•çš„ï¼Œæ‰€ä»¥è¿™é‡ŒæŠŠå¼•ç”¨æ›¿æ¢å‡ºæ¥ï¼Œä¹‹åè¦æ³¨æ„æŠŠåˆæ³•å¼•ç”¨è¿˜å›å»ã€‚ 1234567891011121314151617impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; type Item = &amp;&#x27;a mut T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; let uninit = MaybeUninit::&lt;&amp;&#x27;a mut List&lt;T&gt;&gt;::uninit(); match std::mem::replace(&amp;mut self.0,unsafe&#123;uninit.assume_init()&#125;) &#123; List::Cons(item,rest) =&gt;&#123; self.0 = rest.as_mut(); Some(item) &#125;, nil @ List::Nil =&gt; &#123; self.0 = nil; None &#125; &#125; &#125;&#125; ä¸è¿‡æ—¢ç„¶ç”¨äº†unsafeï¼Œç›´æ¥ç”¨std::ptr::readæ›´ç®€æ´ï¼Œè€Œä¸”è¿™é‡Œè¯»å‡ºæ¥æ˜¯å¼•ç”¨ï¼Œä¸ç”¨æ‹…å¿ƒé‡å¤dropã€‚ 12345678910111213141516impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; type Item = &amp;&#x27;a mut T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match unsafe&#123;std::ptr::read(&amp;mut self.0)&#125; &#123; List::Cons(item,rest) =&gt;&#123; self.0 = rest.as_mut(); Some(item) &#125;, nil @ List::Nil =&gt; &#123; self.0 = nil; None &#125; &#125; &#125;&#125; unsafe unsafeè­¦å¯Ÿå‡ºè­¦ï¼ğŸ‘®â€â™€ï¸å› ä¸ºRustçš„å¼ºè¯­æ³•é™åˆ¶ï¼ŒRustçš„unsafeæ˜¯éå¸¸å€¼å¾—äº†è§£çš„ä¸€å—å†…å®¹ï¼Œè€Œå¦ä¸€å—æ˜¯å®ã€‚unsafeä¹Ÿæ²¡æœ‰æƒ³è±¡ä¸­é‚£æ ·ç®€å•ï¼Œunsafeä¸€å¥—ä¸‡äº‹å¤§å‰ã€‚è€Œå‰é¢ä¸¤ä¸ªä¾‹å­æ¯”è¾ƒç®€å•ä½†åŸå› æ˜¯æ¶‰åŠåˆ°çš„éƒ½æ˜¯å¼•ç”¨ï¼Œä¸ç”¨æ‹…å¿ƒå¿˜è®°é‡Šæ”¾å’Œé‡å¤é‡Šæ”¾çš„é—®é¢˜ã€‚ è®©æˆ‘ä»¬é‡æ–°å›é¡¾ä¸€ä¸‹å¼•ç”¨å’Œæ‰€æœ‰æƒè§„åˆ™ã€‚ ä¸€ä¸ªå€¼åŒæ—¶å¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ ä¸€ä¸ªå€¼åŒæ—¶å¯ä»¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå¯å˜å¼•ç”¨å­˜åœ¨çš„åŒæ—¶ä¸èƒ½æœ‰ä¸å¯å˜å¼•ç”¨ å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå—ç”Ÿå‘½å‘¨æœŸé™åˆ¶ è€Œç”Ÿå‘½å‘¨æœŸå°±æ˜¯æŒæœ‰å€¼çš„å½¢å¼å‚æ•°æˆ–å±€éƒ¨å˜é‡çš„ä½œç”¨åŸŸï¼Œå› ä¸ºè¢«åŒ…å«åœ¨ä½œç”¨åŸŸå†…ï¼Œç”±æ‰€æœ‰è€…é‡Šæ”¾å°±å¯ä»¥äº†ï¼Œä¸æ­¤åŒæ—¶ä¹Ÿä¸èƒ½è¶…å‡ºç”Ÿå‘½å‘¨æœŸã€‚è€Œå¯å˜å¼•ç”¨ä¸åŒçš„åœ°æ–¹åœ¨äºä»–åœ¨èµ‹äºˆæ–°å€¼çš„æ—¶å€™ï¼Œä¼šé‡Šæ”¾æ—§å€¼ã€‚ ç°åœ¨ç»™ä»–åŠ ä¸€äº›å°çš„å‡½æ•°ï¼š 1234567891011121314151617181920212223242526impl List&lt;u32&gt; &#123; fn range(l: u32, h: u32) -&gt; List&lt;u32&gt; &#123; let mut r = List::Nil; let mut t = h; while l &lt;= t &#123; r = Cons(t,Box::new(r)); t -= 1; &#125; r &#125;&#125;impl&lt;A&gt; List&lt;A&gt; &#123; fn into_iter(self) -&gt; IntoIter&lt;A&gt; &#123; IntoIter(self) &#125; fn iter(&amp;self) -&gt; Iter&lt;A&gt; &#123; Iter(self) &#125; fn iter_mut(&amp;mut self) -&gt; IterMut&lt;A&gt; &#123; IterMut(self) &#125;&#125; 1234fn main() &#123; let x = List::range(1, 100_000_000).into_iter().fold(0, |_,a| a); print!(&quot;&#123;&#125;&quot;, x)&#125; 123 Finished dev [unoptimized + debuginfo] target(s) in 0.46s Running `target/debug/temp`100000000% æ²¡æœ‰é—®é¢˜ 1234fn main() &#123; let x = List::range(1, 100_000_000).iter().fold(0, |_,a| *a); print!(&quot;&#123;&#125;&quot;, x)&#125; ğŸ’¥Boom 123thread &#x27;main&#x27; has overflowed its stackfatal runtime error: stack overflow[1] 15047 abort (core dumped) cargo run è°ƒè¯•ä¸€ä¸‹é€’å½’dropçˆ†æ ˆï¼Œè€Œç¬¬ä¸€æ®µä¸çˆ†æ˜¯å› ä¸ºæ‰‹åŠ¨å±•å¼€äº† After drop is run, Rust will recursively try to drop all of the fields of self.This is a convenience feature so that you donâ€™t have to write â€œdestructor boilerplateâ€ to drop children. If a struct has no special logic for being dropped other than dropping its children, then it means Drop doesnâ€™t need to be implemented at all!There is no stable way to prevent this behavior in Rust 1.0. å¦‚æœæ‰‹åŠ¨å®ç°Dropï¼Œä½†è¿™é‡Œé“¾è¡¨å’ŒèŠ‚ç‚¹æ˜¯ä¸€ä½“çš„ã€‚è€Œå¯¹Listå®ç°äº†Dropä¹‹åæ— æ³•é€šè¿‡æ¨¡å¼åŒ¹é…å–å€¼ï¼Œåªèƒ½å–å¼•ç”¨ï¼Œè¿™ç›´æ¥å¯¼è‡´Dropå®ç°å¼‚å¸¸å¤æ‚ã€‚ï¼ˆè¿™æ˜¯åŸåšè·³è¿‡çš„åœ°æ–¹ï¼Œè€Œä¸”åŸåšæ—¢ç„¶æåˆ°å‡½æ•°å¼ï¼Œæ²¡æœ‰ç†ç”±ç”¨ä¸€ä¸ªç»“æ„ä½“æ¥ä¿å­˜é“¾è¡¨çš„å¤´ï¼‰ ç”±äºå®ç°Dropä¹‹åæ— æ³•moveï¼Œè¿™é‡Œç”¨std::ptr::readã€‚readæ˜¯å¤åˆ¶ï¼Œå› æ­¤æ˜¯åˆæ³•çš„ã€‚è¿™é‡Œè¦ååˆ†æ³¨æ„ï¼Œä¸ç„¶å¯èƒ½ä¼šå‡ºç°é‡å¤é‡Šæ”¾ã€‚è¦ä¹ˆè°ƒç”¨forgetï¼Œä¸åšæ¸…ç†ï¼Œè¦ä¹ˆç”¨std::ptr::writeå†™å›å»ï¼Œè€Œwriteæ˜¯ç›´æ¥è¦†ç›–ï¼Œä¸ä¼šé‡Šæ”¾æ—§å€¼ã€‚ å¦å¤–ï¼Œæ ˆä¸Šçš„å˜é‡æœ¬èº«å°±ä¸éœ€è¦æ˜¾å¼é‡Šæ”¾ï¼Œå‡½æ•°è°ƒç”¨å®Œæ¯•ï¼Œæ ˆå¸§æ”¶ç¼©è‡ªåŠ¨å°±é‡Šæ”¾äº†ï¼Œæ‰€ä»¥è¿™é‡Œæ ¸å¿ƒæ˜¯å †ä¸Šçš„ç»“æ„ã€‚ 123456789101112impl &lt;T&gt; Drop for List&lt;T&gt; &#123; fn drop(&amp;mut self) &#123; unsafe&#123; let mut t = std::ptr::read(self); while let Cons(_,xs) = &amp;t &#123; let next = std::ptr::read(xs); std::ptr::write(&amp;mut t, *next); &#125; std::ptr::write(self, t); &#125; &#125;&#125; å®ç°Dropä¹‹åIntoIterä¹Ÿéœ€è¦ä¿®æ”¹ï¼š 12345678910111213141516impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; &#123; type Item = T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match &amp;self.0 &#123; Cons(item, rest) =&gt; &#123; unsafe&#123; let x = std::ptr::read(item); let xs = std::ptr::read(rest); std::ptr::write(&amp;mut self.0, *xs); Some(x) &#125; &#125; Nil =&gt; None, &#125; &#125;&#125;","categories":[{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"}],"tags":[]},{"title":"Debug OpenJDK","slug":"debug-jdk","date":"2018-11-17T20:13:16.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2018/11/17/debug-jdk/","link":"","permalink":"https://ezksd.github.io/2018/11/17/debug-jdk/","excerpt":"","text":"ç¯å¢ƒ ç³»ç»Ÿï¼š ubuntu 18.10 ç¼–è¾‘å™¨ï¼š vscode JDKç‰ˆæœ¬ï¼š openjdk8u ä¸‹è½½Openjdkå„ç‰ˆæœ¬éƒ½åœ¨https://hg.openjdk.java.netï¼Œè¿™é‡Œé€‰æ‹©jdk8uã€‚ 1234hg clone https://hg.openjdk.java.net/jdk8u/jdk8u openjdkcd openjdkchmod u+x get_source.sh ./get_source.sh hgå‘½ä»¤éœ€è¦äº‹å…ˆå®‰è£…Mercurial. 1sudo apt install mercurial å¦‚æœä¸‹è½½ç¼“æ…¢å°è¯•è®¾ç½®ä»£ç†,åœ¨/etc/mercurial/hgrcæ–‡ä»¶é‡ŒåŠ å…¥ï¼ˆçœŸçš„éå¸¸æ…¢ï¼‰ï¼š 123456# system-wide mercurial configuration file# See hgrc(5) for more information[http_proxy]host=host:port[https_proxy]host=host:port ç¼–è¯‘ç¼–è¯‘jdkéœ€è¦ç³»ç»Ÿå·²ç»å®‰è£…äº†JDKï¼Œç§°ä¸ºbootstrap jdkï¼ˆè€Œä¸”æœ€å¥½æ˜¯å‰ä¸€ä¸ªç‰ˆæœ¬ï¼Œæ¯”å¦‚ç¼–è¯‘jdk8ï¼Œé‚£ä¹ˆäº‹å…ˆè£…å¥½jdk7ï¼‰ï¼Œå¦‚æœä¸å¯¹å¯ä»¥é€šè¿‡ä¿®æ”¹ç¯å¢ƒå˜é‡æˆ–è€…åŠ ä¸Šconfigureå‚æ•°--with-boot-jdkå‚æ•°æŒ‡å®šjdkè·¯å¾„ã€‚ 1234java -versionopenjdk version &quot;1.8.0_181&quot;OpenJDK Runtime Environment (build 1.8.0_181-8u181-b13-1ubuntu0.18.10.1-b13)OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode) å®‰è£…ä¾èµ–ï¼ˆå‚è€ƒREADMEï¼Œä¹Ÿå¯ä»¥configureä¹‹åä¾æ®æç¤ºå®‰è£…ï¼‰ï¼š 1sudo apt-get install libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev é…ç½®ï¼š 12chmod u+x configure$ ./configure --enable-debug --with-native-debug-symbols=external debug-levelåˆ†slowdebugå’Œfastdebugï¼Œâ€“enable-debugé»˜è®¤ä½fast-debugï¼Œdebug symbolé»˜è®¤æ˜¯å‹ç¼©çš„ï¼Œè®¾ç½®â€“with-native-debug-symbols=externalå…å»æ‰‹åŠ¨è§£å‹çš„å·¥ä½œã€‚ å°†hotspot/make/linux/makefiles/gcc.makeä¸­çš„WARNINGS_ARE_ERRORS = -Werroræ”¹ä¸ºWARNINGS_ARE_ERRORS = -wï¼Œä¸ç„¶ä¼šå‡ºç°å¦‚ä¸‹å¼‚å¸¸ã€‚ 1cc1plus: all warnings being treated as errors ç¼–è¯‘: 1make all å®Œæˆ 1234build/linux-x86_64-normal-server-fastdebug/jdk/bin/java -versionopenjdk version &quot;1.8.0-normal-fastdebug&quot;OpenJDK Runtime Environment (build 1.8.0-internal-fastdebug)OpenJDK 64-Bit Server VM (build 25.71-b00-fastdebug, mixed mode) è°ƒè¯•vscodeéœ€è¦å…ˆè£…ä¸Šcpptoolsæ’ä»¶ï¼Œå¯ä»¥ç›´æ¥åœ¨æ’ä»¶å•†åŸé‡Œæœç´¢c/c++ã€‚ æ‰“å¼€VSCode, File -&gt; OpenFolderé€‰ä¸­jdkæ–‡ä»¶å¤¹ï¼Œç‚¹å‡»å·¦ä¾§è™«è™«å›¾æ ‡ï¼Œç‚¹å‡»add configurationé€‰ä¸­c/c++ (gdb) Launch,ä¿®æ”¹lauch.jsonæ–‡ä»¶ã€‚ 12345678910111213141516171819202122232425262728&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java&quot;, &quot;args&quot;: [&quot;-cp&quot;, &quot;~/Desktop&quot;,&quot;Hello&quot;], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], //&quot;sourceFileMap&quot;:&#123;&quot;/build/glibc-YYA7BZ/glibc-2.31&quot;: &quot;/usr/src/glibc/glibc-2.31&quot;&#125; &#125; ]&#125; è¿™é‡Œä¸»è¦ä¿®æ”¹programå‚æ•°å’Œargså‚æ•°ï¼Œprogramè®¾ç½®ä¸ºbuild/linux-x86_64-normal-server-fastdebug/jdk/bin/javaï¼Œargsè®¾ç½®ä¸ºç¼–è¯‘å¥½çš„classç±»åï¼ˆæˆ‘æ”¾åœ¨æ¡Œé¢ï¼‰ï¼Œæ–­ç‚¹æ‰“åœ¨src/share/vm/prims/jni.cppæ–‡ä»¶ä¸‹çš„JNI_CreateJavaVMå‡½æ•°ä¸Šï¼Œè¿™é‡Œæ˜¯jvmçš„å…¥å£ï¼Œä½ ä¹Ÿå¯ä»¥æ‰“åœ¨jdk/src/share/bin/main.c çš„mainå‡½æ•°ä¸Šï¼Œè¿™æ ·å·®ä¸å¤šå°±å¯ä»¥å¼€å§‹è°ƒäº†ï¼Œä½†æ˜¯æŸ¥çœ‹æ–‡ä»¶ä¼šéå¸¸å¤šçš„é”™è¯¯æç¤ºæ‰¾ä¸åˆ°æ–‡ä»¶ã€‚ æ¥ä¸‹æ¥åœ¨.vscodeæ–‡ä»¶å¤¹ä¸‹åˆ›å»ºc_cpp_properties.jsonæ–‡ä»¶ï¼Œè¾“å…¥ä»¥ä¸‹å†…å®¹ã€‚ 12345678910111213141516171819&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/hotspot/src/**&quot;, //hotspotæºæ–‡ä»¶ &quot;$&#123;workspaceFolder&#125;/build/linux-x86_64-normal-server-slowdebug/hotspot/linux_amd64_compiler2/generated/**&quot;, //ç¼–è¯‘ç”Ÿæˆçš„ä»£ç  &quot;$&#123;workspaceFolder&#125;/jdk/src/**&quot;, //jdkæ ¹ç›®å½•ï¼Œå…¶ä¸­åŒ…æ‹¬å¤§éƒ¨åˆ†çš„å¯æ‰§è¡Œæ–‡ä»¶çš„æºæ–‡ä»¶æ¯”å¦‚javaï¼Œjavacï¼Œè¿˜æœ‰ä¸€äº›nativeæ–¹æ³•çš„å®ç° &quot;/usr/src/glibc/glibc-2.31/**&quot; , //libcæºä»£ç  ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++98&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot; &#125; ], &quot;version&quot;: 4&#125; æœ€åä¸€ä¸ªé—®é¢˜å°±æ˜¯è°ƒè¯•é‡åˆ°libcé‡Œçš„å‡½æ•°çš„æ—¶å€™ä¼šå¼¹çª—æç¤ºæ‰¾ä¸åˆ°å¯¹åº”çš„æ–‡ä»¶ï¼Œé¦–å…ˆæŒ‰ç…§ç³»ç»Ÿæç¤ºå®‰è£…å¯¹åº”ç‰ˆæœ¬çš„glibcæºæ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥æ‰‹åŠ¨ä¸‹è½½ã€‚ 1sudo apt-get install glibc-source æˆ‘è¿™é‡Œç‰ˆæœ¬æ˜¯glibc-2.31ï¼Œå®‰è£…åœ¨/usr/src/glibc/glibc-2.31.tar.xzï¼Œè§£å‹åœ¨å½“å‰ç›®å½•ã€‚ 12cd /usr/src/glibctar -xvf glibc-2.29.tar.xz æ¥ä¸‹æ¥ï¼Œåœ¨å¼¹é”™è¯¯çš„æ—¶å€™æ³¨æ„æç¤ºæ–‡ä»¶è·¯å¾„ï¼Œæ¯”å¦‚æˆ‘è¿™é‡Œæ˜¯/build/glibc-KRRWSm/glibc-2.29ï¼Œåœ¨launch.jsonçš„configurationsé‡Œé¢åŠ å…¥&quot;sourceFileMap&quot;:&#123;&quot;/build/glibc-KRRWSm/glibc-2.29&quot;: &quot;/usr/src/glibc/glibc-2.29&quot;&#125;ã€‚sourceFileMapé…ç½®å¯ä»¥å‚è€ƒä¸‹é¢çš„æ–‡æ¡£ï¼šhttps://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#source-path-remappingã€‚","categories":[{"name":"jvm","slug":"jvm","permalink":"https://ezksd.github.io/categories/jvm/"},{"name":"vscode","slug":"vscode","permalink":"https://ezksd.github.io/categories/vscode/"}],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"},{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"},{"name":"shell","slug":"shell","permalink":"https://ezksd.github.io/categories/shell/"},{"name":"jvm","slug":"jvm","permalink":"https://ezksd.github.io/categories/jvm/"},{"name":"vscode","slug":"vscode","permalink":"https://ezksd.github.io/categories/vscode/"}],"tags":[]}