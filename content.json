{"meta":{"title":"Ezksd","subtitle":"ezksd's blog","description":null,"author":"ezksd","url":"https://ezksd.github.io","root":"/"},"pages":[{"title":"About","date":"2020-07-29T11:47:51.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"about/index.html","permalink":"https://ezksd.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-02-05T11:17:40.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"categories/index.html","permalink":"https://ezksd.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-02-05T11:17:26.000Z","updated":"2021-06-26T13:14:30.037Z","comments":true,"path":"tags/index.html","permalink":"https://ezksd.github.io/tags/index.html","excerpt":"","text":"&lt;%- tagcloud({min_font: 20, max_font: 20, unit: px, amount:30, color: true, start_color: #b700ff, end_color: #b700ff, level: 3}) %&gt;"}],"posts":[{"title":"Java DIRECT IO","slug":"java-direct-io","date":"2021-01-09T15:09:47.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2021/01/09/java-direct-io/","link":"","permalink":"https://ezksd.github.io/2021/01/09/java-direct-io/","excerpt":"","text":"java 10 支持了DIRECT IO，可以绕过page cache直接写文件。 12Path path = Paths.get(&quot;test.txt&quot;);FileChannel channel = FileChannel.open(path, StandardOpenOption.WRITE, ExtendedOpenOption.DIRECT); DIRECT IO需要对齐，但是他有一些非常微妙的地方。 那些地方需要对齐：123Util.checkChannelPositionAligned(position(), alignment);Util.checkBufferPositionAligned(bb, pos, alignment);Util.checkRemainingBufferSizeAligned(rem, alignment); 分别是： 文件写入位置 directBuffer起始地址 directBuffer中剩余数据的长度 他们都必须是alignment的整数倍。 按多少字节对齐？12345678910111213141516171819202122232425262728JNIEXPORT jint JNICALLJava_sun_nio_ch_FileDispatcherImpl_setDirect0(JNIEnv *env, jclass clazz, jobject fdo)&#123; jint fd = fdval(env, fdo); jint result;#ifdef MACOSX struct statvfs file_stat;#else struct statvfs64 file_stat;#endif#ifdef MACOSX result = fstatvfs(fd, &amp;file_stat);#else result = fstatvfs64(fd, &amp;file_stat);#endif if(result == -1) &#123; JNU_ThrowIOExceptionWithLastError(env, &quot;DirectIO setup failed&quot;); return result; &#125; else &#123; result = (int)file_stat.f_frsize; &#125;#else result == -1;#endif return result;&#125; statvfs.frsize是文件系统的逻辑块大小，可能包含多个物理块。 unsigned long f_frsize; /* Fragment size */ 如何获得起始起始位置是对齐的directBuffer系统分配的内存虚拟地址并不确定，需要分配大一些的空间(pagesize + capcity)，只使用其中的一部分。 1long size = Math.max(1L, (long)cap + (pa ? ps : 0)); 假如设置了-Dsun.nio.PageAlignDirectMemory=true参数会自动对齐。 注：这场jdk里的注释是错的，-XX:MaxDirectMemorySize=没有任何作用 这里DirectByteBuffer会把整段分配的内存写0，而不仅仅是用到的部分。导致没用到的虚拟内存也会分配物理内存。 1234567891011121314long base = 0;try &#123; base = UNSAFE.allocateMemory(size);&#125; catch (OutOfMemoryError x) &#123; Bits.unreserveMemory(size, cap); throw x;&#125;UNSAFE.setMemory(base, size, (byte) 0);if (pa &amp;&amp; (base % ps != 0)) &#123; // Round up to page boundary address = base + ps - (base &amp; (ps - 1));&#125; else &#123; address = base;&#125; 假设分配一页内存，虚拟地址横跨两页，最终会导致分配两倍的物理内存。如果分配小量内存或者开启大页情况可能会更严重。 12345678910111213141516public class Hello &#123; static final int _4K = 4096; static Object[] save = new Object[256 * 1024]; public static void main(String[] args) &#123; for (int i = 0; i &lt; 256 * 1024; i++) &#123; ByteBuffer buffer = ByteBuffer.allocateDirect(_4K); save[i] = buffer; &#125; try &#123; new CountDownLatch(1).await(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 这份代码不带对齐参数占用的物理内存约为1G，而加上-Dsun.nio.PageAlignDirectMemory=true将占用2G。 1234567$ java -XX:NativeMemoryTracking=summary -XX:MaxDirectMemorySize=1g -Dsun.nio.PageAlignDirectMemory=true Hello$ jcmd 29084 VM.native_memory29084:Native Memory Tracking:Total: reserved=7840547KB, committed=2470423KB- Other (reserved=2097152KB, committed=2097152KB) (malloc=2097152KB #262144) 注意到-XX:MaxDirectMemorySize=1g，但是DirectMemory远远超出了1g。 MaxDirectMemorySize的逻辑Bits.tryReserveMemory是按分配的容量算的，而不是实际分配的内存大小。 12345678910111213141516private static boolean tryReserveMemory(long size, int cap) &#123; // -XX:MaxDirectMemorySize limits the total capacity rather than the // actual memory usage, which will differ when buffers are page // aligned. long totalCap; while (cap &lt;= MAX_MEMORY - (totalCap = TOTAL_CAPACITY.get())) &#123; if (TOTAL_CAPACITY.compareAndSet(totalCap, totalCap + cap)) &#123; RESERVED_MEMORY.addAndGet(size); COUNT.incrementAndGet(); return true; &#125; &#125; return false;&#125; 而在开启对齐的时候size = cap + pageSize，显然size要比cap大得多。","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Java类型系统","slug":"java-type-system","date":"2020-12-31T00:48:14.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/12/31/java-type-system/","link":"","permalink":"https://ezksd.github.io/2020/12/31/java-type-system/","excerpt":"","text":"κiζsヤ當非主流成為主流シ\bjava一直是面向对象语言的代表。目前大部分语言都支持面向对象，同时面向对象的概念也变得模糊。 Java的面向对象主要有两点： 数据和函数打包，在这里函数称为方法，他的第一个参数默认是this。 基于继承和子类型的类型系统。 这两点又有一点交叉，this指向的对象类型不同，会分派到不同的方法（虚方法）。而对于第一点，他又和闭包类似，Java8以前用对象来模拟函数，事实上展示了两者的共性。而这种设计暗示对象是有状态的，这种设计和函数式不同。在函数式编程中，可变状态应该从参数中传入，从返回值中取出。 而第二点，一直被各种黑的假范型，以及为了兼容裸类型做出的妥协（通配符），也是这个语言最独特（恶心）的地方。 一个反直觉的例子1234567static &lt;E&gt; void test(List&lt;E&gt; l1,List&lt;E&gt; l2)&#123;&#125;public static void main(String[] args) &#123; List&lt;?&gt; list = new ArrayList&lt;&gt;(); test(list, list);&#125; 123456789101112Main.java:12: error: method test in class Main cannot be applied to given types; test(list, list); ^ required: List&lt;E&gt;,List&lt;E&gt; found: List&lt;CAP#1&gt;,List&lt;CAP#2&gt; reason: inference variable E has incompatible equality constraints CAP#2,CAP#1 where E is a type-variable: E extends Object declared in method &lt;E&gt;test(List&lt;E&gt;,List&lt;E&gt;) where CAP#1,CAP#2 are fresh type-variables: CAP#1 extends Object from capture of ? CAP#2 extends Object from capture of ?1 error 错误提示了这两个List&lt;E&gt;不是一个东西，在不同的地方代表着不同的类型。假如我们想暗示两个参数是同一个类型，像这样： 1234567static &lt;E,L extends List&lt;E&gt;&gt; void test(L l1,L l2)&#123;&#125;public static void main(String[] args) &#123; List&lt;?&gt; list = new ArrayList&lt;&gt;(); test(list, list);&#125; 12345678910111213Main.java:12: error: method test in class Main cannot be applied to given types; test(list, list); ^ required: L,L found: List&lt;CAP#1&gt;,List&lt;CAP#2&gt; reason: inference variable E has incompatible equality constraints CAP#1,CAP#2 where L,E are type-variables: L extends List&lt;E&gt; declared in method &lt;E,L&gt;test(L,L) E extends Object declared in method &lt;E,L&gt;test(L,L) where CAP#1,CAP#2 are fresh type-variables: CAP#1 extends Object from capture of ? CAP#2 extends Object from capture of ?1 error 依然不能通过编译，问题在于List的元素类型对不上。于是我们加上? extends E，l1和l2的类型参数依然不同，但这一次E代表这两个类型的共同上界。 1234567static &lt;E,L extends List&lt;? extends E&gt;&gt; void test(L l1,L l2)&#123;&#125;public static void main(String[] args) &#123; List&lt;?&gt; list = new ArrayList&lt;&gt;(); test(list, list);&#125; 存在类型此处不深入讨论类型论，而且我也不懂，仅展示存在类型和范型之间的区别。以Rust为例，这个语言就不支持子类型，同时Rust中的闭包又如此特别。比如： 123456fn main() &#123; let i = 0; let j = 1; let mut f = || i; f = || j;&#125; 123= note: expected closure `[closure@src/main.rs:4:17: 4:21]` found closure `[closure@src/main.rs:5:9: 5:13]`= note: no two closures, even if identical, have the same type 世界上没有两片相同的叶子，Rust里也没有两个相同的closuure 而一个独一无二的东西，在不支持子类型的同时，要如何表示他的类型呢？答案就是存在类型。 1234fn closure() -&gt; impl Fn() -&gt; i32&#123; let i = 1; move || i&#125; 返回值在函数内部给出，此时编译器已经不能通过类型推导来帮我们做决定了，这也是存在类型在Rust中的用处。 回到javajava的范型也有一些类似，他是不变的（相对于协变和逆变），比如常见的例子: 123456interface Fruit &#123;&#125;static class Apple implements Fruit&#123;&#125;public static void main(String[] args) &#123; LinkedList&lt;Fruit&gt; list = new LinkedList&lt;Apple&gt;();&#125; 1java: incompatible types: java.util.LinkedList&lt;com.company.Main.Apple&gt; cannot be converted to java.util.LinkedList&lt;com.company.Main.Fruit&gt; 这个例子是一个协变的逻辑，而List&lt;Fruit&gt;的在类型参数Fruit处是不变的。java的协变与其他语言（c#,scala)区别在于java的协变逻辑在使用的时候给出，而其他语言在定义的时候给出。或者说他可能和协变本身就不一样，java语言规范中关于协变唯二提到的部分是虚方法中的返回值协变，以及协变返回值方法和方法覆盖之间的关系。 而这一点也同样指出了返回值和参数类型推导的不同。 123List&lt;String&gt; test()&#123; return (List&lt;? extends String&gt;)null;&#125; 显然这份代码也无法通过编译，因为返回值协变的前提是返回值的类型必须是方法标出的返回值类型的子类型。 如何理解存在类型如此难以理解和反直觉，在Rust语言中也同样是一个槛。和其他的语法限制一样，他包含两部分： 如何理解语法本身 在限制之下如何去写代码 我认为第二部分更加重要，比如Rust的lifetime和ownership本身并不难理解，但是形成一套什么样的代码是合法的直觉相当的困难。 从这一点上来说，在什么时候用协变逆变可以参考scala的说法： These positions are classied as covariant for the types of immutable fields and method results, and contravariant for method argument types and upper type parameter bounds. Type arguments to a non-variant type parameter are always in non-variant position. The position flips between contra- and co-variant inside a type argument that corresponds to a contravariant parameter. The type system enforces that covariant (respectively, contravariant) type parameters are only used in covariant (contravariant) positions. 简要来说代表不可变的字段和返回值的类型参数是协变的，而代表方法的参数和类型参数上界的类型参数是逆变的，在逆变参数的内部协/逆变又是反过来的。他们同时出现的时候就会特别阴间： 123public static &lt;T&gt; void sort(List&lt;? extends Comparable&lt;? super T&gt;&gt; list) &#123; list.sort(null);&#125; 这是标准库中的代码，List的元素类型是协变的，Comparable的类型参数是compareTo的参数的类型是逆变的。 协变相对于逆变更容易理解，一个集合类型存储着不同的元素，这些元素有公共父类型。但协变的前提是集合不可变，这也是为什么java的协变数组是有问题的。 12345678interface Fruit &#123;&#125;static class Apple implements Fruit&#123;&#125;static class Orange implements Fruit&#123;&#125;public static void main(String[] args) &#123; Fruit[] fruit = new Apple[1]; fruit[0] = new Orange();&#125; 12Exception in thread &quot;main&quot; java.lang.ArrayStoreException: com.company.Main$Orange at com.company.Main.main(Main.java:17) 而理解逆变的关键在于应该把函数作为一个整体，而不是单独去看类型参数为什么应该是下界（super)。可变性本身描述的就是假如A是B的子类型，两个值之间的子类型关系。而对于函数来说，一个函数类型A对于另一个函数类型B适用面更广，那么A类型的值可以出现在要求出现B类型的地方。 以水果为例，假设水果之间可以比较重量。如果不标出下界，父类已经实现了Comparable接口，但是不能编译通过，这无形中限制了代码的表达能力。 12345678910111213141516interface Fruit extends Comparable&lt;Fruit&gt; &#123; @Override default int compareTo(Fruit o)&#123; return 0; &#125;&#125;static class Apple implements Fruit&#123;&#125;static &lt;T extends Comparable&lt;T&gt;&gt; void sort1(List&lt;T&gt; list) &#123;&#125;static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort2(List&lt;T&gt; list) &#123;&#125;public static void main(String[] args)&#123; ArrayList&lt;Apple&gt; list = new ArrayList&lt;&gt;(); sort1(list); //编译错误 sort2(list); //合法&#125; java里还有一些高级特性，不过适用范围比较局限交类型1234567891011class A&#123; void ha()&#123;&#125;&#125;interface B&#123; void he();&#125;&lt;T extends A &amp; B&gt; void fun(T t)&#123; t.ha(); t.he();&#125; 由于Java本身不支持多继承，交类型里只能有一个class而且只能放在第一位。 并类型123456789101112131415class A extends Exception&#123;&#125;class B extends Exception&#123;&#125;void fun()&#123; try &#123; if(flag) throw new A(); else throw new B(); &#125; catch (A | B a) &#123; a.printStackTrace(); &#125;&#125; 只能在异常块中使用，表示可能出现的异常类型。","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"},{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"}],"tags":[]},{"title":"NIO和epoll的关系","slug":"nio","date":"2020-08-27T18:15:14.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/08/27/nio/","link":"","permalink":"https://ezksd.github.io/2020/08/27/nio/","excerpt":"","text":"nio在linux对应的实现是epoll。在linux中，所有I/O都抽象为文件（包括网络和文件读写)，用文件描述符（fd）来标识。fd是一个非负整数， 其中0，1，2分别对应stdin，stdout，stderr。epoll包含三个函数，分别是： epoll_create：创建一个epoll instance并返回一个fd代表他，对应Selector。 epoll_ctl：注册I/O事件，对应SelectableChannel.register()。 epoll_wait：等待I/O事件，对应Selector.select()。 OP_ACCEPT 和 OP_CONNECT EPOLLIN The associated file is available for read(2) operations. EPOLLOUT The associated file is available for write(2) operations. EPOLLRDHUP (since Linux 2.6.17) Stream socket peer closed connection, or shut down writing half of connection. (This flag is especially useful for writ‐ ing simple code to detect peer shutdown when using edge-trig‐ gered monitoring.) EPOLLPRI There is an exceptional condition on the file descriptor. See the discussion of POLLPRI in poll(2). EPOLLERR Error condition happened on the associated file descriptor. This event is also reported for the write end of a pipe when the read end has been closed. epoll_wait(2) will always report for this event; it is not necessary to set it in events when calling epoll_ctl(). EPOLLHUP Hang up happened on the associated file descriptor. epoll_wait(2) will always wait for this event; it is not nec‐ essary to set it in events when calling epoll_ctl(). Note that when reading from a channel such as a pipe or a stream socket, this event merely indicates that the peer closed its end of the channel. Subsequent reads from the channel will return 0 (end of file) only after all outstanding data in the channel has been consumed. EPOLLET Requests edge-triggered notification for the associated file descriptor. The default behavior for epoll is level-trig‐ gered. See epoll(7) for more detailed information about edge- triggered and level-triggered notification. This flag is an input flag for the event.events field when calling epoll_ctl(); it is never returned by epoll_wait(2). EPOLLONESHOT (since Linux 2.6.2) Requests one-shot notification for the associated file de‐ scriptor. This means that after an event notified for the file descriptor by epoll_wait(2), the file descriptor is dis‐ abled in the interest list and no other events will be re‐ ported by the epoll interface. The user must call epoll_ctl() with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask. This flag is an input flag for the event.events field when calling epoll_ctl(); it is never returned by epoll_wait(2). 可以注意到，和SelectionKey中的事件有一些差别，比如这里没有OP_ACCEPT和OP_CONNECT。那么这两个事件是做什么的🤔？ ACCEPT123456public int translateInterestOps(int ops) &#123; int newOps = 0; if ((ops &amp; SelectionKey.OP_ACCEPT) != 0) newOps |= Net.POLLIN; return newOps;&#125; OP_ACCEPT变成了Net.POLLIN。而对于CONNECT： 12345678910public int translateInterestOps(int ops) &#123; int newOps = 0; if ((ops &amp; SelectionKey.OP_READ) != 0) newOps |= Net.POLLIN; if ((ops &amp; SelectionKey.OP_WRITE) != 0) newOps |= Net.POLLOUT; if ((ops &amp; SelectionKey.OP_CONNECT) != 0) newOps |= Net.POLLCONN; return newOps;&#125; POLLCONN和POLLOUT一样均为4，通过socket的状态进行区分。如果socket未连接代表OP_CONNECT,已连接代表OP_WRITE。如果说把POLLIN拆分成ACCEPT和READ尚可理解，那把OUT拆成WRITE和CONNECT是为什么？ OP_CONNECT是在做什么这里有一个非常容易误解的地方，客户端调用connect,服务端调触发OP_ACCEPT事件，调用accept之后客户端触发OP_CONNECT事件，调用finishConnect。看上去和三次握手完全一致，但完全不是那回事，通过wireshark调试得知在服务端调用accept时三次握手已经完成了。那么OP_CONNECT和finishConnect分别是在做什么？ 1boolean polled = Net.pollConnectNow(fd); 这是一个native方法： 12345678910111213jint fd = fdval(env, fdo);struct pollfd poller;int result;poller.fd = fd;poller.events = POLLOUT;poller.revents = 0;if (timeout &lt; -1) &#123; timeout = -1;&#125; else if (timeout &gt; INT_MAX) &#123; timeout = INT_MAX;&#125;result = poll(&amp;poller, 1, (int)timeout); 可以看到jni方法只是在用poll()检查该fd的POLLOUT事件。而POLLOUT表示socket缓冲区可写，隐含连接已经建立。所以对于阻塞的finishConnect()，他会阻塞到连接建立，而非阻塞的finishConnect，用返回值代表连接是否建立。这个方法名很有误导性，建议改为doesItFinishConnect，或者说非阻塞的connect好像用处不大。 错误epoll事件转换为NIO事件： 123456789101112131415161718192021222324252627282930313233343536373839404142public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl sk) &#123; int intOps = sk.nioInterestOps(); // Do this just once, it synchronizes int oldOps = sk.nioReadyOps(); int newOps = initialOps; if ((ops &amp; Net.POLLNVAL) != 0) &#123; // This should only happen if this channel is pre-closed while a // selection operation is in progress // ## Throw an error if this channel has not been pre-closed return false; &#125; if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) &#123; newOps = intOps; sk.nioReadyOps(newOps); // No need to poll again in checkConnect, // the error will be detected there readyToConnect = true; return (newOps &amp; ~oldOps) != 0; &#125; if (((ops &amp; Net.POLLIN) != 0) &amp;&amp; ((intOps &amp; SelectionKey.OP_READ) != 0) &amp;&amp; (state == ST_CONNECTED)) newOps |= SelectionKey.OP_READ; if (((ops &amp; Net.POLLCONN) != 0) &amp;&amp; ((intOps &amp; SelectionKey.OP_CONNECT) != 0) &amp;&amp; ((state == ST_UNCONNECTED) || (state == ST_PENDING))) &#123; newOps |= SelectionKey.OP_CONNECT; readyToConnect = true; &#125; if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp; ((intOps &amp; SelectionKey.OP_WRITE) != 0) &amp;&amp; (state == ST_CONNECTED)) newOps |= SelectionKey.OP_WRITE; sk.nioReadyOps(newOps); return (newOps &amp; ~oldOps) != 0;&#125; 可以看出： POLLNVAL没有设置任何ReadyOps，POLLNAVAL的值为32，在上表中没有对应的项。如注释所说，应该是API使用错误不去管他。 POLLERR和ROLLHUP原封不动复制了intOps，也就是会触发所有注册的事件。 这里还翻到Netty的一个issuehttps://github.com/netty/netty/issues/924。 123456789101112131415161718192021if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123; // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking // See https://github.com/netty/netty/issues/924 int ops = k.interestOps(); ops &amp;= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect();&#125;// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write ch.unsafe().forceFlush();&#125;// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead// to a spin loopif ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123; unsafe.read();&#125; netty的OP_CONNECT处理在第一位，当对方发送Reset时，首先会进入unsafe.finishConnect()，而这里并没有取消事件也没有关闭连接的逻辑。 最后注意到上面代码的最后一行，Java把IN事件分离成ACCEPT和READ，但是Netty又把ACCEPT和READ统一起来，ServerSocket的读处理就是调用Accept: 1234567891011121314151617181920protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123; SocketChannel ch = SocketUtils.accept(javaChannel()); try &#123; if (ch != null) &#123; buf.add(new NioSocketChannel(this, ch)); return 1; &#125; &#125; catch (Throwable t) &#123; logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, t); try &#123; ch.close(); &#125; catch (Throwable t2) &#123; logger.warn(&quot;Failed to close a socket.&quot;, t2); &#125; &#125; return 0;&#125; 整个事情的感觉就是都有自己这么做的理由，但是组合起来就十分滑稽。","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Java标准库中一处不太合理的地方","slug":"generic-heap","date":"2020-08-05T20:44:34.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/08/05/generic-heap/","link":"","permalink":"https://ezksd.github.io/2020/08/05/generic-heap/","excerpt":"","text":"泛型众所周知，Java的泛型非常拉稀。虽然我认为在表达能力差不多的情况下，别的都可以忍忍。Java的表达能力差在哪里呢： 不能创建泛型数组 可以用Object[]加强制转型，与此同时方法还要加上@SuppressWarnings(“unchecked”)，不然会有编译期警告。 不能通过泛型创建对象 可以把Class&lt;T&gt;作为参数，在内部用反射调构造函数。这种情况非常普遍，但在Java8或以上版本中并不合适。我们可以把参数Class&lt;T&gt;改为Supplier&lt;T&gt;，讲究一点可以写成Supplier&lt;? extends T&gt;，然后调用的时候传入构造器方法引用。（目前还想不出特别好的例子展示这两者的区别，想到再补） 123456static &lt;E&gt; E construct(Supplier&lt;? extends E&gt; sup)&#123; return sup.get();&#125;public static void main(String[] args) &#123; String s = construct(String::new);&#125; 举一个netty的例子： 1234567891011121314Bootstrap b = new Bootstrap();b.group(group) .channel(NioSocketChannel.class) // 看这里 .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT)); &#125; p.addLast(new EchoClientHandler()); &#125; &#125;); 而channel函数是这么定义的： 12345public B channel(Class&lt;? extends C&gt; channelClass) &#123; return channelFactory(new ReflectiveChannelFactory&lt;C&gt;( ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;) ));&#125; 这里ChannelFactory等价于Supplier&lt;T extends Channel&gt;， 只需要用channelFactory(NioSocketChannel::new)就可以了。::new还比.class少一个字符，在java9以上版本反射可能会出现微妙的问题，而反射唯一的优点是能调用私有的构造函数。 不支持协变逆变，或者说以一个难看的方式支持部分协变逆变 暂时没有第四 可变性(协变/逆变)Java的可变性和其他语言(比如Scala, C#)里最大的区别在于Java的可变性在使用的时候标明(比如声明一个变量，代入类型参数)，而其他语言在定义类/接口/特质的时候标明。 1Collection&lt;? extends A&gt; collections = ...; 123class Collection[+A]&#123;&#125; 问题标准库里的PriorityQueue&lt;E&gt;，也就是我们常说的堆，定义是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; private final Comparator&lt;? super E&gt; comparator; public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null); &#125; public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null); &#125; public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator); &#125; public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125; //看这里 private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] es) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = es[parent]; if (key.compareTo((T) e) &gt;= 0) break; es[k] = e; k = parent; &#125; es[k] = key; &#125; 这段代码的意思是，可以手动指定Comparator，如果T本身是Comparable的子类型的话也可以不用指定，此时comparator为空，比较的时候会强制转型为Comparable。但是如果这个时候我不小心创建了一个没有实现Comparable的优先级队列，编译期不会有任何问题，运行的时候就炸了。也太不小心了但是其实是可以在编译期避免这种情况： 123456789101112131415161718192021public class Heap&lt;E&gt; &#123; Comparator&lt;? super E&gt; comp; E[] array; @SuppressWarnings(&quot;unchecked&quot;) private Heap(Comparator&lt;? super E&gt; comp, int size) &#123; this.comp = comp; this.array = (E[]) new Object[size]; &#125; static &lt;E extends Comparable&lt;? super E&gt;&gt; Heap&lt;E&gt; newHeap() &#123; return newHeap(Comparable::compareTo); &#125; static &lt;E&gt; Heap&lt;E&gt; newHeap(Comparator&lt;? super E&gt; comp) &#123; return newHeap(comp,16); &#125; static &lt;E&gt; Heap&lt;E&gt; newHeap(Comparator&lt;? super E&gt; comp, int size) &#123; return new Heap&lt;&gt;(comp,size); &#125;&#125; 当然这里是静态方法，因为用构造器的话行不通。","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Java 14 特性简介","slug":"java-14","date":"2020-06-23T10:00:00.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2020/06/23/java-14/","link":"","permalink":"https://ezksd.github.io/2020/06/23/java-14/","excerpt":"","text":"java 14出来已经有一段时间了，相比之前的小幅更新，这一次的新增语法特性还是比较多的。而且前面的众多特性，包括14中的部分特性都是为模式匹配做准备，基本上就差临门一脚了。本文将仅对新增语法特性做一个简单介绍。 305: Pattern Matching for instanceof (Preview)这是一个preview特性，需要编译的时候加上--enable-preview参数，同时还要指定--release或者--source，仅作尝鲜使用。 这个特性本身的作用是简化instance of的使用，因为如果instance of为真，那么之后的强制转型就显得很多余。比如： 1234if (obj instanceof String) &#123; String s = (String) obj; // use s&#125; 现在可以写成： 12345if (obj instanceof String s) &#123; // can use s here&#125; else &#123; // can&#x27;t use s here&#125; 注意到，新的语法instance of类型之后多了一个变量，这也是唯一的区别。虽然他看上去仍然去有点多余，为什么不在对应的作用域内obj的类型直接就当成String呢。我猜测是这个特性为了和后续的模式匹配的解构风格保持一致，毕竟这个特性本身就是为模式匹配铺路的。 359: Records (Preview)这依然是一个preview特性，它很像c的结构体，但准确来讲它更像scala的case class。加上JEP 360: Sealed Classes (Preview)之后，就等于支持代数数据类型了，当然目前也差不多可以用了，差别是模式匹配的时候编译器能否判断代码有没有把所有的可能性写全。抛开这些，Record可以视为一个语法糖，因为他编译之后可以还原成一个等价的class。利用这个特性，我们可以少写很多代码，因为record可以自动生成：构造器，get方法，toString，hashCode，equals方法，注意：这里并没有set方法，因为record默认是不可变的。而且record可以实现接口，但是不能继承其他类，同时除此以外和一个普通的class没有什么差别。 1record Point(int x, int y) &#123; &#125; 语法如上，因为record还能添加自定义构造器和实现方法，为了保持一致还是保留了大括号（虽然看上去很多余）． JEP 361: Switch Expressions (Standard)这个之前就有，不过在java 14中不再是preview特性了，简单将，switch语句是一个表达式，它是有值的．当然语法和switch statement有一些差别． 123456switch (day) &#123; case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6); case TUESDAY -&gt; System.out.println(7); case THURSDAY, SATURDAY -&gt; System.out.println(8); case WEDNESDAY -&gt; System.out.println(9);&#125; 这段代码并没有体现出switch expressions是一个表达式，与switch statement的最大差别是他没有fall through特性，不需要到处加break了． 王垠曾经讲：访问者模式只是模式匹配丑陋的模仿(大意)．观点正确与否暂且不论，模式匹配和观察者模式的确有很多共同之处．比如一个访问者接口的定义(以遍历二叉树为例)： 1234public interface Visitor &#123; public void visit(Node n); public void visit(Leaf l);&#125; 和haskell的模式匹配定义如出一辙 123visit :: Tree e -&gt; ()visit (Node n) = ...visit (Leaf f) = ... 虽然这些语法离完整的模式匹配还差一脚，不过已经差不多够了，接下来就用新的语法写一个简单的计算器． 计算器首先是token的定义。scala中有与case class对应的cass object，也就是单例的record。不过java目前还没有，用enum代替： 1234567891011interface Token &#123; &#125;record Number(int i) implements Token&#123; &#125;enum Operator implements Token&#123; ADD,MINUS,MULTIPLY,DIVIDED&#125;enum Bracket implements Token&#123; LEFT,RIGHT;&#125; 由于java标准库中没有tuple，再加一个tuple，用来当多返回值，同时返回token和所在的位置． 1record Tuple&lt;A,B&gt;(A a,B b)&#123;&#125; 然后是parser部分，省去了tokenizer 123456789101112131415161718192021222324252627282930313233343536373839static Optional&lt;List&lt;Token&gt;&gt; parseAll(String s) &#123; var i = 0; var list = new LinkedList&lt;Token&gt;(); while (i &lt; s.length()) &#123; var r = parse(s, i); if (r.isPresent()) &#123; list.add(r.get().a()); i = r.get().b(); &#125; else &#123; return Optional.empty(); &#125; &#125; return Optional.of(list);&#125;static Optional&lt;Tuple&lt;Token, Integer&gt;&gt; parse(String s, int p) &#123; var c = s.charAt(p); return switch (c) &#123; case &#x27;(&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Bracket.LEFT, p + 1)); case &#x27;)&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Bracket.RIGHT, p + 1)); case &#x27;*&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.MULTIPLY, p + 1)); case &#x27;/&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.DIVIDED, p + 1)); case &#x27;+&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.ADD, p + 1)); case &#x27;-&#x27; -&gt; Optional.of(new Tuple&lt;&gt;(Operator.MINUS, p + 1)); default -&gt; parseNumber(s, p); &#125;;&#125;static Optional&lt;Tuple&lt;Token, Integer&gt;&gt; parseNumber(String s, int p) &#123; int i = 0; if (!Character.isDigit(s.charAt(p)))&#123; return Optional.empty(); &#125; while (p &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(p))) &#123; i = i * 10 + (s.charAt(p++) - &#x27;0&#x27;); &#125; return Optional.of(new Tuple&lt;&gt;(new Number(i), p));&#125; 接下来是解释部分，左递归消除就不赘述了，简单说下文法： 12345expr = term expr1expr1 = (+/-) term expr1 | εterm = digit | term1term1 = (*//) digit term1 | εdigit = 整数 | &#x27;(&#x27; expr &#x27;)&#x27; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static Optional&lt;Tuple&lt;Double,Integer&gt;&gt; expr(List&lt;Token&gt; list,int p)&#123; var term = term(list, p); return term.flatMap(x -&gt;&#123; var tuples = expr1(list, x.b()); return tuples.map(xs -&gt; &#123; double s = x.a(); for (var tuple : xs.a()) &#123; switch (tuple.a()) &#123; case ADD -&gt; s += tuple.b(); case MINUS -&gt; s -= tuple.b(); default -&gt; throw new UnsupportedOperationException(); &#125; &#125; return new Tuple&lt;&gt;(s, xs.b()); &#125;); &#125;); &#125; static Optional&lt;Tuple&lt;List&lt;Tuple&lt;Operator, Double&gt;&gt;, Integer&gt;&gt; expr1(List&lt;Token&gt; list, int p)&#123; var result = new LinkedList&lt;Tuple&lt;Operator,Double&gt;&gt;(); while (p &lt; list.size()) &#123; var token = list.get(p); var term = term(list, p + 1); if(term.isPresent() &amp;&amp; (token == Operator.ADD || token == Operator.MINUS))&#123; result.add(new Tuple&lt;&gt;((Operator)token, term.get().a())); p = p + 2; &#125;else &#123; break; &#125; &#125; return Optional.of(new Tuple&lt;&gt;(result, p)); &#125; static Optional&lt;Tuple&lt;Double,Integer&gt;&gt; term(List&lt;Token&gt; list,int p)&#123; var digit = digit(list, p); return digit.flatMap(x -&gt; &#123; var tuples = term1(list, x.b()); return tuples.map(xs -&gt; &#123; double s = x.a(); for (Tuple&lt;Operator, Double&gt; tuple : xs.a()) &#123; switch (tuple.a()) &#123; case MULTIPLY -&gt; s *= tuple.b(); case DIVIDED -&gt; s /= tuple.b(); default -&gt; throw new UnsupportedOperationException(); &#125; &#125; return new Tuple&lt;&gt;(s,xs.b()); &#125;); &#125;); &#125; static Optional&lt;Tuple&lt;List&lt;Tuple&lt;Operator,Double&gt;&gt;,Integer&gt;&gt; term1(List&lt;Token&gt; list,int p)&#123; var result = new LinkedList&lt;Tuple&lt;Operator,Double&gt;&gt;(); while (p &lt; list.size()) &#123; var token = list.get(p); var term = digit(list, p + 1); if(term.isPresent() &amp;&amp; (token == Operator.MULTIPLY || token == Operator.DIVIDED))&#123; result.add(new Tuple&lt;&gt;((Operator)token, term.get().a())); p = p + 2; &#125;else &#123; break; &#125; &#125; return Optional.of(new Tuple&lt;&gt;(result, p)); &#125; static Optional&lt;Tuple&lt;Double, Integer&gt;&gt; digit(List&lt;Token&gt; list, int p) &#123; if (p &lt; list.size())&#123; var t = list.get(p); if (t instanceof Number) return Optional.of(new Tuple&lt;&gt;(((double) ((Number) list.get(p)).i()), p + 1)); else if(t == Bracket.LEFT)&#123; return expr(list, p + 1).flatMap(x -&gt; &#123; if (x.b() &lt; list.size() &amp;&amp; list.get(x.b()) == Bracket.RIGHT) &#123; return Optional.of(new Tuple&lt;&gt;(x.a(), x.b() + 1)); &#125;else &#123; return Optional.empty(); &#125; &#125;); &#125; &#125; return Optional.empty(); &#125; 最后返回的是值和字符所在位置的tuple，再加一个包装函数就完工了： 12345static Optional&lt;Double&gt; caculate(List&lt;Token&gt; tokens) &#123; var list = new ArrayList&lt;Token&gt;(tokens.size()); list.addAll(tokens); return expr(list,0).map(Tuple::a);&#125; 完整代码在这里。","categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"}],"tags":[]},{"title":"Rust的缺点","slug":"rust","date":"2019-06-02T19:17:15.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2019/06/02/rust/","link":"","permalink":"https://ezksd.github.io/2019/06/02/rust/","excerpt":"","text":"这世界有太多的传教士了，比如一部分Haskell传教士会拿一个两行的快排，但是不告诉你那不是原地排序，而等价的原地排序可能比java还长。 那Rust真的有传教士说的那么美吗，是否遗漏了什么。 trait不是类型，同时也不支持子类型当然，这可能是设计需要，但让人难受但地方，我先把他归类为缺点。 123fn compare(a: Ord,b: Ord) -&gt; bool&#123; a &lt; b&#125; 1234567error[E0038]: the trait `std::cmp::Ord` cannot be made into an object --&gt; src/main.rs:2:15 |2 | fn compare(a: Ord,b: Ord) -&gt; bool&#123; | ^^^ the trait `std::cmp::Ord` cannot be made into an object | = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses 不过你可以用类型推导，这里要求该类型实现了Ord trait， 于是我们就可以用&lt;来比较了。 123fn compare&lt;A:Ord&gt;(a: A,b: A) -&gt; bool&#123; a &lt; b&#125; 这与子类型有本质的区别，比如在返回值位置就没办法这么写了。返回值在函数内部已经给出，推导的时候就对不上了。 再愛你，依然是兩個人～ 123fn compare&lt;A:Ord&gt;() -&gt; A&#123; 1&#125; 12345678910error[E0308]: mismatched types --&gt; src/main.rs:3:5 |2 | fn compare&lt;A:Ord&gt;() -&gt; A&#123; | - expected `A` because of return type3 | 1 | ^ expected type parameter, found integer | = note: expected type `A` found type `&#123;integer&#125;` 不是所有的值都有一个明确的类型，比如闭包，这个时候就要存在类型： 世界上没有两片相同的叶子，Rust里也没有两个的闭包 12345678fn counter() -&gt; impl Fn() -&gt; i32&#123; let mut i = 0; || &#123; let r = i; i = i + 1; r &#125;&#125; 与此同时存在类型是一个非常难用的东西，他对应存在量词，而范型对应全称量词。 延时求值1234trait Iterator&#123; type Item; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;&#125; 听上去很美，但假设他不做所谓的延时求值，甚至都没有办法抽象出来一套东西。 比如map方法并没有立刻转换，而是直接把原来的Iterator和函数包在了结构体里： 12345fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; whereSelf: Sized, F: FnMut(Self::Item) -&gt; B,&#123; Map::new(self, f)&#125; 假如你想把他的返回值改成Iterator&lt;Item=B&gt;是编译不过的，因为trait不是类型。这里需要一个具体的类型，比如结构体或者枚举，于是你会看到大量这样的代码： 1234567fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, U::IntoIter&gt;fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U::IntoIter&gt;fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;fn enumerate(self) -&gt; Enumerate&lt;Self&gt; fn peekable(self) -&gt; Peekable&lt;Self&gt; 每定义一个新的方法，你就需要定义一个新的结构体（因为你不能在同一个结构体上实现同一个trait两次），然后再在结构体上实现trait的方法。这种代码风格Java程序员一定很熟悉，我把他称为实名内部类。如果比Iterator官方实现的代码长度，Rust肯定是首屈一指的。 如果只是代码长倒不是很大的问题，毕竟我是一名Java程序员。 再看一个具体一点的问题： 12345fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt;where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -&gt; U,&#123; FlatMap::new(self, f)&#125; F（这里代表一个函数）的返回值类型U是根据类型推导来的，这就造成一个问题，假如函数中有if else或者模式匹配这样的分支，两个分支的类型会对不上。注意这里如果不用return，if表达式的类型就已经对不上了（在Rust中if else是一个表达式，和Scala类似）。 1234567let j = (1..9).flat_map(|x|&#123; if (x % 2) == 0 &#123; return empty(); &#125;else&#123; return vec![x].iter(); &#125;&#125;).collect(); 12345678error[E0308]: mismatched types --&gt; src/main.rs:8:16 |8 | return vec![x].iter(); | ^^^^^^^^^^^^^^ expected struct `std::iter::Empty`, found struct `std::slice::Iter` | = note: expected type `std::iter::Empty&lt;_&gt;` found type `std::slice::Iter&lt;&#x27;_, &#123;integer&#125;&gt;` 假如你的代码里出现了分支，其中一个用的map,另外一个用的filter,那他类型是对不上的，甚至于说都是map,闭包的类型也对不上（闭包是Map的类型参数）。 如果你听说Rust支持type class，想来搞点函数式，你是否搞错了什么？ 面向对象 你不要把FP那套东西搞过来，同时也不要OOP那套东西搞过来，Rust就是Rust。 Rust可以用trait object来表达多态，但是编译器需要在编译期知道函数的参数、局部变量的大小，所以这里必须套上一个引用或者Box。而且编译器对trait object有额外的限制： Object Safety Is Required for Trait ObjectsYou can only make object-safe traits into trait objects. Some complex rules govern all the properties that make a trait object safe, but in practice, only two rules are relevant. A trait is object safe if all the methods defined in the trait have the following properties: The return type isn’t Self. There are no generic type parameters. https://doc.rust-lang.org/book/ch17-02-trait-objects.html 所有的方法都不能有泛型参数，零成本抽象。不过在老一点的文档里有另外一条，这一点我也认为非常坑爹，Rust的文档散落在世界的各个角落里。 你渴望力量吗？ https://doc.rust-lang.org/book/title-page.html https://doc.rust-lang.org/edition-guide/rust-2018/index.html https://doc.rust-lang.org/1.19.0/book/first-edition/README.html 在老版的Rust Book里面关于object safety有更详细的描述： The error says that Clone is not ‘object-safe’. Only traits that are object-safe can be made into trait objects. A trait is object-safe if both of these are true: the trait does not require that Self: Sized all of its methods are object-safe So what makes a method object-safe? Each method must require that Self: Sized or all of the following: must not have any type parameters must not use Self Each method must require that Self: Sized or all of the following… 新版不仅把这句话删了，我不知道是怎么想的。这里可以理解为加了Self: Sized 就可以绕过这个限制，与此同时trait object就不能再调用这个方法了，欲练此功，必先自宫。 依据这一条，我们可以这样来定义Iterator。 1234567trait Iterator&lt;E&gt;&#123; fn next(&amp;mut self) -&gt; E; fn flat_map&lt;B,F&gt;(self,f: F) -&gt; FlatMap&lt;Self,F&gt; where Self: Sized,F: Fn(E) -&gt; Box&lt;dyn Iterator&lt;B&gt;&gt;&#123; Map(self,f) &#125; &#125; 缺点就是你需要在各种地方套Box。 引用 叔叔，叔叔，听说你们这个语言写不了链表是吗？ Rust的引用规则很简单：可变引用可以同时存在多个，不可以引用同时只能存在一个，而可变引用存在的时候不能创建不可变引用。 常见的链表next是一个可变引用，tail指针也是可变的，他们同时指向链表的最后一个节点，这是Rust绕不过去的坎。 规则简单，不代表他用起来容易。你可以看到这个规则，就马上想到Rust不用unsafe无法实现链表，然后享受一个周末而不是和编译器死磕吗？ 生命周期 王垠：rust所谓的生命周期就是把引用计数限制为1，那处理起来当然简单了。 不得不佩服王垠的敏锐，那么这句话要如何理解呢？因为看上去rust允许多个不可变引用。 这也是生命周期的设计理念，引用的生命周期被包含在值的生命周期内，所以他可以直接忽略，由所有者负责释放，而所有者就是那个1。这也是为什么你想在线程之间传引用通常是一个错误的选择。 而可变引用的不同之处在于，假如把引用指向另外一个值，他需要释放前一个值。 这都不知道？再去看看TRPL吧，都在里面。 TRPL说到这里就不得不提The Rust Programming Language，Rust吹们把他简称为TRPL以示尊敬。你必须知道它，同时也必须知道这个缩写。 那么TRPL，有没有那么详细？显然是没有的，首先他相对于老的文档做过一定的删减，比如上面提到的trait object。那回到正题，我认为这篇文档漏掉了一个相当重要的东西就是std::mem::replace，Option里把他包装成take。他的作用是把旧的值取出来，同时给一个新值。这样我们就可以对原来的值随意操作了。我认为在你知道这个东西之前，你可能至少会浪费一个星期尝试去对可变引用做模式匹配，直到你知道有这个东西，或者精通unsafe。 比如，假如我想把栈顶取出来，然后向后挪一位，可能会这么实现。 1234567891011121314151617181920enum Stack&lt;E&gt; &#123; More(E,Box&lt;Stack&lt;E&gt;&gt;), Less&#125;impl &lt;E&gt; Stack&lt;E&gt; &#123; fn new() -&gt; Stack&lt;E&gt;&#123; Stack::Less &#125; fn pop(&amp;mut self) -&gt; Option&lt;E&gt;&#123; match self &#123; Stack::More(item,next) =&gt; &#123; *self = **next; Some(*item) &#125;, Stack::Less =&gt; None &#125; &#125;&#125; 那么你显然犯了错误，self可变引用存在的同时，模式匹配会创建新的引用。那有了replace，就可以这样写。 12345678910fn pop(&amp;mut self) -&gt; Option&lt;E&gt;&#123; let pre = std::mem::replace(self, Stack::Less); match pre &#123; Stack::More(item,next) =&gt; &#123; *self = *next; Some(item) &#125;, Stack::Less =&gt; None &#125;&#125; 但是这显然不够零成本抽象，因为Less是一个垃圾值，随后就会被释放掉。当然你也可以用unsafe。 123456789fn pop(&amp;mut self) -&gt; Option&lt;E&gt;&#123; match unsafe&#123;std::ptr::read(self)&#125; &#123; Stack::More(item,next) =&gt; &#123; unsafe&#123;std::ptr::write(self, *next)&#125; Some(item) &#125;, Stack::Less =&gt; None &#125;&#125; 什么，竟然有人在用unsafe? unsafe 警察，出警👮‍♀️！ 学习成本 很多人以为Rust学习成本很高，他只不过把复杂的部分都暴露出来了。 不，Rust的学习成本比你想象的还要高。不仅仅是学习语法，而是花大量但时间总结在这一套限制之下该如何写代码。正如同学习如何戴着镣铐跳舞💃💃💃。 那么Rust值得吗？","categories":[{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"}],"tags":[]},{"title":"自定义Zsh主题","slug":"custom-zsh-theme","date":"2019-05-06T23:45:44.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2019/05/06/custom-zsh-theme/","link":"","permalink":"https://ezksd.github.io/2019/05/06/custom-zsh-theme/","excerpt":"","text":"一直在用zsh的主题ys。一直有一个很烦的问题，刚进入shell的时候最上面有一个空行看起来十分难受。今天想起来解决了一下，发现并不困难。 zsh的主题就是一个shell文件，修改变量PROMT就好了，而ys这个主题ys.zsh-theme 123456789101112PROMPT=&quot;%&#123;$terminfo[bold]$fg[blue]%&#125;#%&#123;$reset_color%&#125; \\%(#,%&#123;$bg[yellow]%&#125;%&#123;$fg[black]%&#125;%n%&#123;$reset_color%&#125;,%&#123;$fg[cyan]%&#125;%n) \\%&#123;$fg[white]%&#125;@ \\%&#123;$fg[green]%&#125;%m \\%&#123;$fg[white]%&#125;in \\%&#123;$terminfo[bold]$fg[yellow]%&#125;%~%&#123;$reset_color%&#125;\\$&#123;hg_info&#125;\\$&#123;git_info&#125;\\ \\%&#123;$fg[white]%&#125;[%*] $exit_code%&#123;$terminfo[bold]$fg[red]%&#125;$ %&#123;$reset_color%&#125;&quot; 在开头的时候就加了一个换行，把他去掉命令之间又太紧凑了。而PROMT是一个变量，赋值是一次性的，在里面插一个带状态的函数又行不通。 好在文档里有一个函数precmd，接下来就很简单了，把这个插入到要修改的主题，再把PROMPT再把前面的换行删掉就好了。 12345678local prompt_prefix_flag=falsefunction precmd()&#123; if $prompt_prefix_flag; then echo &quot;&quot; else prompt_prefix_flag=true fi&#125;","categories":[{"name":"shell","slug":"shell","permalink":"https://ezksd.github.io/categories/shell/"}],"tags":[]},{"title":"Rust实现函数式列表","slug":"rust-functional-list","date":"2019-03-27T15:49:18.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2019/03/27/rust-functional-list/","link":"","permalink":"https://ezksd.github.io/2019/03/27/rust-functional-list/","excerpt":"","text":"本文有参考（Learn Rust With Entirely Too Many Linked Lists)[https://rust-unofficial.github.io/too-many-lists/index.html]，但原文中跳过了很多难处理的情况，比如用Option代替代数数据类型，链表和节点分开定义，显然这显然很不函数式。 Rust和Haskell非常相似，比如有ADT、模式匹配，trait/impl和class/instance几乎是一样的。列表是函数式语言中最常用的数据结构，下面尝试在Rust中实现他。 首先在Haskell中List大概是这样： 1data List a = Cons a (List a) | Nil 翻译成Rust： 1234enum List&lt;T&gt;&#123; Cons(T,List&lt;T&gt;), Nil&#125; 12345678error[E0072]: recursive type `List` has infinite size --&gt; src/lib.rs:6:1 |6 | enum List&lt;T&gt;&#123; | ^^^^^^^^^^^^ recursive type has infinite size7 | Cons(T,List&lt;T&gt;), | ------- recursive without indirection | Rust需要在编译期知道知道结构体/枚举的大小，这里是递归的数据结构，而引用或是指针大小是固定的。涉及到引用就必须加上lifetime，然后它就变成了这样。 1234enum List&lt;&#x27;a,T&gt;&#123; Cons(T,&amp;&#x27;a List&lt;&#x27;a,T&gt;), Nil&#125; 栈上引用可能会出现悬挂指针的问题。 cannot return value referencing temporary valuereturns a value referencing data owned by the current function Box A pointer type for heap allocation.Box&lt;T&gt;, casually referred to as a ‘box’, provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope. Box是在堆上分配的。 1234567891011121314enum List&lt;T&gt; &#123; Cons(T, Box&lt;List&lt;T&gt;&gt;), Nil,&#125;impl List&lt;u32&gt; &#123; fn range(l: i32, h: i32) -&gt; List&lt;i32&gt; &#123; if l &lt; h &#123; List::Cons(l, Box::new(List::range(l + 1, h))) &#125; else &#123; List::Nil &#125; &#125;&#125; 迭代器Iterator需要实现的方法签名: 1fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; 对应不同类型的元素（Self::Item)，但结构体本身还是必要，因为需要保存中间遍历的位置。 T -&gt; IntoIter &amp;T -&gt; Iter &amp;mut T -&gt; IterMut 先从IntoIter开始，初步实现： 123456789101112131415struct IntoIter&lt;T&gt;(List&lt;T&gt;);impl &lt;T&gt; Iterator for IntoIter&lt;T&gt;&#123; type Item = T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match self.0 &#123; List::Cons(item,rest) =&gt; &#123; self.0 = *rest; Some(item) &#125; List::Nil =&gt; None &#125; &#125;&#125; 1234567891011error[E0507]: cannot move out of `self.0.1` which is behind a mutable reference --&gt; src/main.rs:21:15 |21 | match self.0 &#123; | ^^^^^^ help: consider borrowing here: `&amp;self.0`22 | List::Cons(item,rest) =&gt; &#123; | ---- | | | data moved here | move occurs because `rest` has type `std::boxed::Box&lt;List&lt;T&gt;&gt;`, which does not implement the `Copy` trait ^^^^ ^^^^ List,Box均没有实现Copy，所以出现了move，但是引用没有所有权。 std::mem::replacehttps://doc.rust-lang.org/std/mem/fn.replace.html 12pub fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T// Moves src into the referenced dest, returning the previous dest value.Neither value is dropped. 先塞一个List::Nil进去把旧值换出来，这样就获得了旧值的所有权。Option的take方法就是replace的包装。 12345678910111213impl &lt;T&gt; Iterator for IntoIter&lt;T&gt;&#123; type Item = T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match std::mem::replace(&amp;mut self.0,List::Nil) &#123; List::Cons(item,rest) =&gt; &#123; self.0 = *rest; Some(item) &#125; List::Nil =&gt; None &#125; &#125;&#125; Iter（也就是Item类型为&amp;T）比较顺畅，因为有引用加上了生命周期，返回值和列表生命周期一致。 12345678910111213141516struct Iter&lt;&#x27;a,T&gt;(&amp;&#x27;a List&lt;T&gt;);impl &lt;&#x27;a,T&gt; Iterator for Iter&lt;&#x27;a,T&gt;&#123; type Item = &amp;&#x27;a T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match self.0 &#123; List::Cons(item,rest) =&gt; &#123; self.0 = rest; Some(item) &#125; List::Nil =&gt; None &#125; &#125;&#125; 但是对于元素类型为&amp;mut T的迭代器又有新的问题。（像素级拷贝上述代码，就不贴了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162error[E0495]: cannot infer an appropriate lifetime for pattern due to conflicting requirements --&gt; src/main.rs:54:24 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^ |note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 52:5... --&gt; src/main.rs:52:5 |52 | fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^note: ...so that reference does not outlive borrowed content --&gt; src/main.rs:54:24 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^note: but, the lifetime must be valid for the lifetime `&#x27;a` as defined on the impl at 49:6... --&gt; src/main.rs:49:6 |49 | impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; | ^^note: ...so that the types are compatible --&gt; src/main.rs:52:46 |52 | fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; | ______________________________________________^53 | | match self.0 &#123;54 | | List::Cons(item,rest) =&gt;&#123;55 | | self.0 = rest.as_mut();... |63 | | &#125;64 | | &#125; | |_____^ = note: expected `Iterator` found `Iterator`error[E0495]: cannot infer an appropriate lifetime for pattern due to conflicting requirements --&gt; src/main.rs:54:29 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^ |note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 52:5... --&gt; src/main.rs:52:5 |52 | fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^note: ...so that reference does not outlive borrowed content --&gt; src/main.rs:54:29 |54 | List::Cons(item,rest) =&gt;&#123; | ^^^^note: but, the lifetime must be valid for the lifetime `&#x27;a` as defined on the impl at 49:6... --&gt; src/main.rs:49:6 |49 | impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; | ^^note: ...so that reference does not outlive borrowed content --&gt; src/main.rs:55:26 |55 | self.0 = rest.as_mut(); | ^^^^^^^^^^^^^ 这里self.0分裂成了两个不交叉的可变引用（这是合法的），但是后续self.0还依然持有self的可变引用，因此多个可变引用冲突。但报的是生命周期的错😅。 这一次需要替换的是引用，因此需要创建一个空指针，引用和指针但区别在于，引用是合法的，但指针可能是非法的，所以这里把引用替换出来，之后要注意把合法引用还回去。 1234567891011121314151617impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; type Item = &amp;&#x27;a mut T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; let uninit = MaybeUninit::&lt;&amp;&#x27;a mut List&lt;T&gt;&gt;::uninit(); match std::mem::replace(&amp;mut self.0,unsafe&#123;uninit.assume_init()&#125;) &#123; List::Cons(item,rest) =&gt;&#123; self.0 = rest.as_mut(); Some(item) &#125;, nil @ List::Nil =&gt; &#123; self.0 = nil; None &#125; &#125; &#125;&#125; 不过既然用了unsafe，直接用std::ptr::read更简洁，而且这里读出来是引用，不用担心重复drop。 12345678910111213141516impl&lt;&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;a,T&gt;&#123; type Item = &amp;&#x27;a mut T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match unsafe&#123;std::ptr::read(&amp;mut self.0)&#125; &#123; List::Cons(item,rest) =&gt;&#123; self.0 = rest.as_mut(); Some(item) &#125;, nil @ List::Nil =&gt; &#123; self.0 = nil; None &#125; &#125; &#125;&#125; unsafe unsafe警察出警！👮‍♀️因为Rust的强语法限制，Rust的unsafe是非常值得了解的一块内容，而另一块是宏。unsafe也没有想象中那样简单，unsafe一套万事大吉。而前面两个例子比较简单但原因是涉及到的都是引用，不用担心忘记释放和重复释放的问题。 让我们重新回顾一下引用和所有权规则。 一个值同时可以有多个不可变引用 一个值同时可以有一个可变引用，可变引用存在的同时不能有不可变引用 引用的生命周期受生命周期限制 而生命周期就是持有值的形式参数或局部变量的作用域，因为被包含在作用域内，由所有者释放就可以了，与此同时也不能超出生命周期。而可变引用不同的地方在于他在赋予新值的时候，会释放旧值。 现在给他加一些小的函数： 1234567891011121314151617181920212223242526impl List&lt;u32&gt; &#123; fn range(l: u32, h: u32) -&gt; List&lt;u32&gt; &#123; let mut r = List::Nil; let mut t = h; while l &lt;= t &#123; r = Cons(t,Box::new(r)); t -= 1; &#125; r &#125;&#125;impl&lt;A&gt; List&lt;A&gt; &#123; fn into_iter(self) -&gt; IntoIter&lt;A&gt; &#123; IntoIter(self) &#125; fn iter(&amp;self) -&gt; Iter&lt;A&gt; &#123; Iter(self) &#125; fn iter_mut(&amp;mut self) -&gt; IterMut&lt;A&gt; &#123; IterMut(self) &#125;&#125; 1234fn main() &#123; let x = List::range(1, 100_000_000).into_iter().fold(0, |_,a| a); print!(&quot;&#123;&#125;&quot;, x)&#125; 123 Finished dev [unoptimized + debuginfo] target(s) in 0.46s Running `target/debug/temp`100000000% 没有问题 1234fn main() &#123; let x = List::range(1, 100_000_000).iter().fold(0, |_,a| *a); print!(&quot;&#123;&#125;&quot;, x)&#125; 💥Boom 123thread &#x27;main&#x27; has overflowed its stackfatal runtime error: stack overflow[1] 15047 abort (core dumped) cargo run 调试一下递归drop爆栈，而第一段不爆是因为手动展开了 After drop is run, Rust will recursively try to drop all of the fields of self.This is a convenience feature so that you don’t have to write “destructor boilerplate” to drop children. If a struct has no special logic for being dropped other than dropping its children, then it means Drop doesn’t need to be implemented at all!There is no stable way to prevent this behavior in Rust 1.0. 如果手动实现Drop，但这里链表和节点是一体的。而对List实现了Drop之后无法通过模式匹配取值，只能取引用，这直接导致Drop实现异常复杂。（这是原博跳过的地方，而且原博既然提到函数式，没有理由用一个结构体来保存链表的头） 由于实现Drop之后无法move，这里用std::ptr::read。read是复制，因此是合法的。这里要十分注意，不然可能会出现重复释放。要么调用forget，不做清理，要么用std::ptr::write写回去，而write是直接覆盖，不会释放旧值。 另外，栈上的变量本身就不需要显式释放，函数调用完毕，栈帧收缩自动就释放了，所以这里核心是堆上的结构。 123456789101112impl &lt;T&gt; Drop for List&lt;T&gt; &#123; fn drop(&amp;mut self) &#123; unsafe&#123; let mut t = std::ptr::read(self); while let Cons(_,xs) = &amp;t &#123; let next = std::ptr::read(xs); std::ptr::write(&amp;mut t, *next); &#125; std::ptr::write(self, t); &#125; &#125;&#125; 实现Drop之后IntoIter也需要修改： 12345678910111213141516impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; &#123; type Item = T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; match &amp;self.0 &#123; Cons(item, rest) =&gt; &#123; unsafe&#123; let x = std::ptr::read(item); let xs = std::ptr::read(rest); std::ptr::write(&amp;mut self.0, *xs); Some(x) &#125; &#125; Nil =&gt; None, &#125; &#125;&#125;","categories":[{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"}],"tags":[]},{"title":"Debug OpenJDK","slug":"debug-jdk","date":"2018-11-17T20:13:16.000Z","updated":"2021-06-26T13:14:30.033Z","comments":true,"path":"2018/11/17/debug-jdk/","link":"","permalink":"https://ezksd.github.io/2018/11/17/debug-jdk/","excerpt":"","text":"环境 系统： ubuntu 18.10 编辑器： vscode JDK版本： openjdk8u 下载Openjdk各版本都在https://hg.openjdk.java.net，这里选择jdk8u。 1234hg clone https://hg.openjdk.java.net/jdk8u/jdk8u openjdkcd openjdkchmod u+x get_source.sh ./get_source.sh hg命令需要事先安装Mercurial. 1sudo apt install mercurial 如果下载缓慢尝试设置代理,在/etc/mercurial/hgrc文件里加入（真的非常慢）： 123456# system-wide mercurial configuration file# See hgrc(5) for more information[http_proxy]host=host:port[https_proxy]host=host:port 编译编译jdk需要系统已经安装了JDK，称为bootstrap jdk（而且最好是前一个版本，比如编译jdk8，那么事先装好jdk7），如果不对可以通过修改环境变量或者加上configure参数--with-boot-jdk参数指定jdk路径。 1234java -versionopenjdk version &quot;1.8.0_181&quot;OpenJDK Runtime Environment (build 1.8.0_181-8u181-b13-1ubuntu0.18.10.1-b13)OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode) 安装依赖（参考README，也可以configure之后依据提示安装）： 1sudo apt-get install libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev 配置： 12chmod u+x configure$ ./configure --enable-debug --with-native-debug-symbols=external debug-level分slowdebug和fastdebug，–enable-debug默认位fast-debug，debug symbol默认是压缩的，设置–with-native-debug-symbols=external免去手动解压的工作。 将hotspot/make/linux/makefiles/gcc.make中的WARNINGS_ARE_ERRORS = -Werror改为WARNINGS_ARE_ERRORS = -w，不然会出现如下异常。 1cc1plus: all warnings being treated as errors 编译: 1make all 完成 1234build/linux-x86_64-normal-server-fastdebug/jdk/bin/java -versionopenjdk version &quot;1.8.0-normal-fastdebug&quot;OpenJDK Runtime Environment (build 1.8.0-internal-fastdebug)OpenJDK 64-Bit Server VM (build 25.71-b00-fastdebug, mixed mode) 调试vscode需要先装上cpptools插件，可以直接在插件商城里搜索c/c++。 打开VSCode, File -&gt; OpenFolder选中jdk文件夹，点击左侧虫虫图标，点击add configuration选中c/c++ (gdb) Launch,修改lauch.json文件。 12345678910111213141516171819202122232425262728&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java&quot;, &quot;args&quot;: [&quot;-cp&quot;, &quot;~/Desktop&quot;,&quot;Hello&quot;], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], //&quot;sourceFileMap&quot;:&#123;&quot;/build/glibc-YYA7BZ/glibc-2.31&quot;: &quot;/usr/src/glibc/glibc-2.31&quot;&#125; &#125; ]&#125; 这里主要修改program参数和args参数，program设置为build/linux-x86_64-normal-server-fastdebug/jdk/bin/java，args设置为编译好的class类名（我放在桌面），断点打在src/share/vm/prims/jni.cpp文件下的JNI_CreateJavaVM函数上，这里是jvm的入口，你也可以打在jdk/src/share/bin/main.c 的main函数上，这样差不多就可以开始调了，但是查看文件会非常多的错误提示找不到文件。 接下来在.vscode文件夹下创建c_cpp_properties.json文件，输入以下内容。 12345678910111213141516171819&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/hotspot/src/**&quot;, //hotspot源文件 &quot;$&#123;workspaceFolder&#125;/build/linux-x86_64-normal-server-slowdebug/hotspot/linux_amd64_compiler2/generated/**&quot;, //编译生成的代码 &quot;$&#123;workspaceFolder&#125;/jdk/src/**&quot;, //jdk根目录，其中包括大部分的可执行文件的源文件比如java，javac，还有一些native方法的实现 &quot;/usr/src/glibc/glibc-2.31/**&quot; , //libc源代码 ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++98&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot; &#125; ], &quot;version&quot;: 4&#125; 最后一个问题就是调试遇到libc里的函数的时候会弹窗提示找不到对应的文件，首先按照系统提示安装对应版本的glibc源文件，也可以手动下载。 1sudo apt-get install glibc-source 我这里版本是glibc-2.31，安装在/usr/src/glibc/glibc-2.31.tar.xz，解压在当前目录。 12cd /usr/src/glibctar -xvf glibc-2.29.tar.xz 接下来，在弹错误的时候注意提示文件路径，比如我这里是/build/glibc-KRRWSm/glibc-2.29，在launch.json的configurations里面加入&quot;sourceFileMap&quot;:&#123;&quot;/build/glibc-KRRWSm/glibc-2.29&quot;: &quot;/usr/src/glibc/glibc-2.29&quot;&#125;。sourceFileMap配置可以参考下面的文档：https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#source-path-remapping。","categories":[{"name":"jvm","slug":"jvm","permalink":"https://ezksd.github.io/categories/jvm/"},{"name":"vscode","slug":"vscode","permalink":"https://ezksd.github.io/categories/vscode/"}],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"https://ezksd.github.io/categories/java/"},{"name":"rust","slug":"rust","permalink":"https://ezksd.github.io/categories/rust/"},{"name":"shell","slug":"shell","permalink":"https://ezksd.github.io/categories/shell/"},{"name":"jvm","slug":"jvm","permalink":"https://ezksd.github.io/categories/jvm/"},{"name":"vscode","slug":"vscode","permalink":"https://ezksd.github.io/categories/vscode/"}],"tags":[]}