<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ezksd</title>
  
  <subtitle>ezksd&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ezksd.github.io/"/>
  <updated>2021-06-26T13:14:30.033Z</updated>
  <id>https://ezksd.github.io/</id>
  
  <author>
    <name>ezksd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java DIRECT IO</title>
    <link href="https://ezksd.github.io/2021/01/09/java-direct-io/"/>
    <id>https://ezksd.github.io/2021/01/09/java-direct-io/</id>
    <published>2021-01-09T15:09:47.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<p>java 10 支持了DIRECT IO，可以绕过page cache直接写文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">FileChannel channel = FileChannel.open(path, StandardOpenOption.WRITE, ExtendedOpenOption.DIRECT);</span><br></pre></td></tr></table></figure><p>DIRECT IO需要对齐，但是他有一些非常微妙的地方。</p><h2 id="那些地方需要对齐："><a href="#那些地方需要对齐：" class="headerlink" title="那些地方需要对齐："></a>那些地方需要对齐：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Util.checkChannelPositionAligned(position(), alignment);</span><br><span class="line">Util.checkBufferPositionAligned(bb, pos, alignment);</span><br><span class="line">Util.checkRemainingBufferSizeAligned(rem, alignment);</span><br></pre></td></tr></table></figure><p>分别是：</p><ol><li>文件写入位置</li><li>directBuffer起始地址</li><li>directBuffer中剩余数据的长度</li></ol><p>他们都必须是alignment的整数倍。</p><h2 id="按多少字节对齐？"><a href="#按多少字节对齐？" class="headerlink" title="按多少字节对齐？"></a>按多少字节对齐？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_sun_nio_ch_FileDispatcherImpl_setDirect0</span><span class="params">(JNIEnv *env, jclass clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           jobject fdo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jint fd = <span class="built_in">fdval</span>(env, fdo);</span><br><span class="line">    jint result;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MACOSX</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">statvfs</span> <span class="title">file_stat</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">statvfs64</span> <span class="title">file_stat</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MACOSX</span></span><br><span class="line">    result = <span class="built_in">fstatvfs</span>(fd, &amp;file_stat);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    result = <span class="built_in">fstatvfs64</span>(fd, &amp;file_stat);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">JNU_ThrowIOExceptionWithLastError</span>(env, <span class="string">&quot;DirectIO setup failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = (<span class="keyword">int</span>)file_stat.f_frsize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    result == <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>statvfs.frsize是文件系统的逻辑块大小，可能包含多个物理块。</p><blockquote><p>unsigned long  f_frsize;   /* Fragment size */</p></blockquote><h2 id="如何获得起始起始位置是对齐的directBuffer"><a href="#如何获得起始起始位置是对齐的directBuffer" class="headerlink" title="如何获得起始起始位置是对齐的directBuffer"></a>如何获得起始起始位置是对齐的directBuffer</h2><p>系统分配的内存虚拟地址并不确定，需要分配大一些的空间(pagesize + capcity)，只使用其中的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>假如设置了<code>-Dsun.nio.PageAlignDirectMemory=true</code>参数会自动对齐。</p><blockquote><p>注：这场jdk里的注释是错的，-XX:MaxDirectMemorySize=<size>没有任何作用</p></blockquote><p>这里DirectByteBuffer会把<strong>整段</strong>分配的内存写0，而不仅仅是用到的部分。导致没用到的虚拟内存也会分配物理内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    base = UNSAFE.allocateMemory(size);</span><br><span class="line">&#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">    Bits.unreserveMemory(size, cap);</span><br><span class="line">    <span class="keyword">throw</span> x;</span><br><span class="line">&#125;</span><br><span class="line">UNSAFE.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Round up to page boundary</span></span><br><span class="line">    address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    address = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设分配一页内存，虚拟地址横跨两页，<strong>最终会导致分配两倍的物理内存</strong>。如果分配小量内存或者开启大页情况可能会更严重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4K = <span class="number">4096</span>;</span><br><span class="line">    <span class="keyword">static</span> Object[] save = <span class="keyword">new</span> Object[<span class="number">256</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocateDirect(_4K);</span><br><span class="line">            save[i] = buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份代码不带对齐参数占用的物理内存约为1G，而加上<code>-Dsun.nio.PageAlignDirectMemory=true</code>将占用2G。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -XX:NativeMemoryTracking=summary -XX:MaxDirectMemorySize=1g -Dsun.nio.PageAlignDirectMemory=<span class="literal">true</span> Hello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jcmd 29084 VM.native_memory</span></span><br><span class="line">29084:</span><br><span class="line">Native Memory Tracking:</span><br><span class="line">Total: reserved=7840547KB, committed=2470423KB</span><br><span class="line">-                     Other (reserved=2097152KB, committed=2097152KB)</span><br><span class="line">                            (malloc=2097152KB #262144)</span><br></pre></td></tr></table></figure><p>注意到<code>-XX:MaxDirectMemorySize=1g</code>，但是DirectMemory远远超出了1g。</p><h2 id="MaxDirectMemorySize的逻辑"><a href="#MaxDirectMemorySize的逻辑" class="headerlink" title="MaxDirectMemorySize的逻辑"></a>MaxDirectMemorySize的逻辑</h2><p>Bits.tryReserveMemory是按分配的容量算的，而不是实际分配的内存大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryReserveMemory</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:MaxDirectMemorySize limits the total capacity rather than the</span></span><br><span class="line">    <span class="comment">// actual memory usage, which will differ when buffers are page</span></span><br><span class="line">    <span class="comment">// aligned.</span></span><br><span class="line">    <span class="keyword">long</span> totalCap;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt;= MAX_MEMORY - (totalCap = TOTAL_CAPACITY.get())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TOTAL_CAPACITY.compareAndSet(totalCap, totalCap + cap)) &#123;</span><br><span class="line">            RESERVED_MEMORY.addAndGet(size);</span><br><span class="line">            COUNT.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在开启对齐的时候size = cap + pageSize，显然size要比cap大得多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java 10 支持了DIRECT IO，可以绕过page cache直接写文件。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
      <category term="java" scheme="https://ezksd.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java类型系统</title>
    <link href="https://ezksd.github.io/2020/12/31/java-type-system/"/>
    <id>https://ezksd.github.io/2020/12/31/java-type-system/</id>
    <published>2020-12-31T00:48:14.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>κiζsヤ當非主流成為主流シ<br>java一直是面向对象语言的代表。目前大部分语言都支持面向对象，同时面向对象的概念也变得模糊。</p></blockquote><p>Java的面向对象主要有两点：</p><ol><li>数据和函数打包，在这里函数称为方法，他的第一个参数默认是this。</li><li>基于继承和子类型的类型系统。</li></ol><p>这两点又有一点交叉，this指向的对象类型不同，会分派到不同的方法（虚方法）。而对于第一点，他又和闭包类似，Java8以前用对象来模拟函数，事实上展示了两者的共性。而这种设计暗示对象是有状态的，这种设计和函数式不同。在函数式编程中，可变状态应该从参数中传入，从返回值中取出。</p><p>而第二点，一直被各种黑的假范型，以及为了兼容裸类型做出的妥协（通配符），也是这个语言最独特（恶心）的地方。</p><h2 id="一个反直觉的例子"><a href="#一个反直觉的例子" class="headerlink" title="一个反直觉的例子"></a>一个反直觉的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;E&gt; l1,List&lt;E&gt; l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    test(list, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Main.java:12: error: method <span class="built_in">test</span> <span class="keyword">in</span> class Main cannot be applied to given types;</span><br><span class="line">        <span class="built_in">test</span>(list, list);</span><br><span class="line">        ^</span><br><span class="line">  required: List&lt;E&gt;,List&lt;E&gt;</span><br><span class="line">  found:    List&lt;CAP<span class="comment">#1&gt;,List&lt;CAP#2&gt;</span></span><br><span class="line">  reason: inference variable E has incompatible equality constraints CAP<span class="comment">#2,CAP#1</span></span><br><span class="line">  <span class="built_in">where</span> E is a type-variable:</span><br><span class="line">    E extends Object declared <span class="keyword">in</span> method &lt;E&gt;<span class="built_in">test</span>(List&lt;E&gt;,List&lt;E&gt;)</span><br><span class="line">  <span class="built_in">where</span> CAP<span class="comment">#1,CAP#2 are fresh type-variables:</span></span><br><span class="line">    CAP<span class="comment">#1 extends Object from capture of ?</span></span><br><span class="line">    CAP<span class="comment">#2 extends Object from capture of ?</span></span><br><span class="line">1 error</span><br></pre></td></tr></table></figure><p>错误提示了这两个<code>List&lt;E&gt;</code>不是一个东西，在不同的地方代表着不同的类型。假如我们想暗示两个参数是同一个类型，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E,L extends List&lt;E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(L l1,L l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    test(list, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Main.java:12: error: method <span class="built_in">test</span> <span class="keyword">in</span> class Main cannot be applied to given types;</span><br><span class="line">        <span class="built_in">test</span>(list, list);</span><br><span class="line">        ^</span><br><span class="line">  required: L,L</span><br><span class="line">  found:    List&lt;CAP<span class="comment">#1&gt;,List&lt;CAP#2&gt;</span></span><br><span class="line">  reason: inference variable E has incompatible equality constraints CAP<span class="comment">#1,CAP#2</span></span><br><span class="line">  <span class="built_in">where</span> L,E are type-variables:</span><br><span class="line">    L extends List&lt;E&gt; declared <span class="keyword">in</span> method &lt;E,L&gt;<span class="built_in">test</span>(L,L)</span><br><span class="line">    E extends Object declared <span class="keyword">in</span> method &lt;E,L&gt;<span class="built_in">test</span>(L,L)</span><br><span class="line">  <span class="built_in">where</span> CAP<span class="comment">#1,CAP#2 are fresh type-variables:</span></span><br><span class="line">    CAP<span class="comment">#1 extends Object from capture of ?</span></span><br><span class="line">    CAP<span class="comment">#2 extends Object from capture of ?</span></span><br><span class="line">1 error</span><br></pre></td></tr></table></figure><p>依然不能通过编译，问题在于List的元素类型对不上。于是我们加上<code>? extends E</code>，l1和l2的类型参数依然不同，但这一次E代表这两个类型的共同上界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E,L extends List&lt;? extends E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(L l1,L l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    test(list, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="存在类型"><a href="#存在类型" class="headerlink" title="存在类型"></a>存在类型</h2><p>此处不深入讨论类型论，而且我也不懂，仅展示存在类型和范型之间的区别。以Rust为例，这个语言就不支持子类型，同时Rust中的闭包又如此特别。比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = || i;</span><br><span class="line">    f = || j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">= note: expected closure `[closure@src/main.rs:4:17: 4:21]`</span><br><span class="line">            found closure `[closure@src/main.rs:5:9: 5:13]`</span><br><span class="line">= note: no two closures, even <span class="keyword">if</span> identical, have the same <span class="built_in">type</span></span><br></pre></td></tr></table></figure><blockquote><p>世界上没有两片相同的叶子，Rust里也没有两个相同的closuure</p></blockquote><p>而一个独一无二的东西，在不支持子类型的同时，要如何表示他的类型呢？答案就是存在类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">closure</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>() -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">move</span> || i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值在函数内部给出，此时编译器已经不能通过类型推导来帮我们做决定了，这也是存在类型在Rust中的用处。</p><h2 id="回到java"><a href="#回到java" class="headerlink" title="回到java"></a>回到java</h2><p>java的范型也有一些类似，他是不变的（相对于协变和逆变），比如常见的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Fruit&gt; list = <span class="keyword">new</span> LinkedList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java: incompatible types: java.util.LinkedList&lt;com.company.Main.Apple&gt; cannot be converted to java.util.LinkedList&lt;com.company.Main.Fruit&gt;</span><br></pre></td></tr></table></figure><p>这个例子是一个协变的逻辑，而<code>List&lt;Fruit&gt;</code>的在类型参数Fruit处是不变的。java的协变与其他语言（c#,scala)区别在于java的协变逻辑在使用的时候给出，而其他语言在定义的时候给出。或者说他可能和协变本身就不一样，java语言规范中关于协变唯二提到的部分是虚方法中的返回值协变，以及协变返回值方法和方法覆盖之间的关系。</p><p>而这一点也同样指出了返回值和参数类型推导的不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;? extends String&gt;)<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这份代码也无法通过编译，因为返回值协变的前提是<strong>返回值</strong>的<strong>类型</strong>必须是方法标出的<strong>返回值类型</strong>的子类型。</p><h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><p>存在类型如此难以理解和反直觉，在Rust语言中也同样是一个槛。和其他的语法限制一样，他包含两部分：</p><ol><li>如何理解语法本身</li><li>在限制之下如何去写代码</li></ol><p>我认为第二部分更加重要，比如Rust的lifetime和ownership本身并不难理解，但是形成一套什么样的代码是合法的直觉相当的困难。</p><p>从这一点上来说，在什么时候用协变逆变可以参考scala的说法：</p><blockquote><p>These positions are classied as covariant for the types of immutable fields and method results, and contravariant for method argument types and upper type parameter bounds. Type arguments to a non-variant type parameter are always in non-variant position. The position flips between contra- and co-variant inside a type argument that corresponds to a contravariant parameter. The type system enforces that covariant (respectively, contravariant) type parameters are only used in covariant (contravariant) positions.</p></blockquote><p>简要来说代表不可变的字段和返回值的类型参数是协变的，而代表方法的参数和类型参数上界的类型参数是逆变的，在逆变参数的内部协/逆变又是反过来的。他们同时出现的时候就会特别阴间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">    list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是标准库中的代码</strong>，List的元素类型是协变的，Comparable的类型参数是compareTo的参数的类型是逆变的。</p><p>协变相对于逆变更容易理解，一个集合类型存储着不同的元素，这些元素有公共父类型。但协变的前提是集合不可变，这也是为什么java的协变数组是有问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">1</span>];</span><br><span class="line">    fruit[<span class="number">0</span>] = <span class="keyword">new</span> Orange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.ArrayStoreException: com.company.Main<span class="variable">$Orange</span></span><br><span class="line">    at com.company.Main.main(Main.java:17)</span><br></pre></td></tr></table></figure><p>而理解逆变的关键在于应该把函数作为一个整体，而不是单独去看类型参数为什么应该是下界（super)。可变性本身描述的就是假如A是B的子类型，两个值之间的子类型关系。而对于函数来说，一个函数类型A对于另一个函数类型B适用面更广，那么A类型的值可以出现在要求出现B类型的地方。</p><p>以水果为例，假设水果之间可以比较重量。如果不标出下界，父类已经实现了Comparable接口，但是不能编译通过，这无形中限制了代码的表达能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Fruit o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort1</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    sort1(list);  <span class="comment">//编译错误</span></span><br><span class="line">    sort2(list);  <span class="comment">//合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java里还有一些高级特性，不过适用范围比较局限"><a href="#java里还有一些高级特性，不过适用范围比较局限" class="headerlink" title="java里还有一些高级特性，不过适用范围比较局限"></a>java里还有一些高级特性，不过适用范围比较局限</h2><h3 id="交类型"><a href="#交类型" class="headerlink" title="交类型"></a>交类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ha</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">he</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T extends A &amp; B&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    t.ha();</span><br><span class="line">    t.he();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java本身不支持多继承，交类型里只能有一个class而且只能放在第一位。</p><h3 id="并类型"><a href="#并类型" class="headerlink" title="并类型"></a>并类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (A | B a) &#123;</span><br><span class="line">        a.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在异常块中使用，表示可能出现的异常类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;κiζsヤ當非主流成為主流シ&lt;br&gt;java一直是面向对象语言的代表。目前大部分语言都支持面向对象，同时面向对象的概念也变得模糊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java的面向对象主要有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据和函数打包
      
    
    </summary>
    
      <category term="java" scheme="https://ezksd.github.io/categories/java/"/>
    
      <category term="rust" scheme="https://ezksd.github.io/categories/rust/"/>
    
    
  </entry>
  
  <entry>
    <title>NIO和epoll的关系</title>
    <link href="https://ezksd.github.io/2020/08/27/nio/"/>
    <id>https://ezksd.github.io/2020/08/27/nio/</id>
    <published>2020-08-27T18:15:14.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<p>nio在linux对应的实现是epoll。在linux中，所有I/O都抽象为文件（包括网络和文件读写)，用文件描述符（fd）来标识。fd是一个非负整数， 其中0，1，2分别对应<code>stdin</code>，<code>stdout</code>，<code>stderr</code>。<br>epoll包含三个函数，分别是：</p><ol><li>epoll_create：创建一个epoll instance并返回一个fd代表他，对应<code>Selector</code>。</li><li>epoll_ctl：注册I/O事件，对应<code>SelectableChannel.register()</code>。</li><li>epoll_wait：等待I/O事件，对应<code>Selector.select()</code>。</li></ol><h2 id="OP-ACCEPT-和-OP-CONNECT"><a href="#OP-ACCEPT-和-OP-CONNECT" class="headerlink" title="OP_ACCEPT 和 OP_CONNECT"></a>OP_ACCEPT 和 OP_CONNECT</h2><blockquote><pre><code>  EPOLLIN         The associated file is available for read(2) operations.  EPOLLOUT         The associated file is available for write(2) operations.  EPOLLRDHUP (since Linux 2.6.17)         Stream socket peer closed connection, or shut down writing         half of connection.  (This flag is especially useful for writ‐         ing simple code to detect peer shutdown when using edge-trig‐         gered monitoring.)  EPOLLPRI         There is an exceptional condition on the file descriptor.  See         the discussion of POLLPRI in poll(2).  EPOLLERR         Error condition happened on the associated file descriptor.         This event is also reported for the write end of a pipe when         the read end has been closed.         epoll_wait(2) will always report for this event; it is not         necessary to set it in events when calling epoll_ctl().  EPOLLHUP         Hang up happened on the associated file descriptor.         epoll_wait(2) will always wait for this event; it is not nec‐         essary to set it in events when calling epoll_ctl().         Note that when reading from a channel such as a pipe or a         stream socket, this event merely indicates that the peer         closed its end of the channel.  Subsequent reads from the         channel will return 0 (end of file) only after all outstanding         data in the channel has been consumed.  EPOLLET         Requests edge-triggered notification for the associated file         descriptor.  The default behavior for epoll is level-trig‐         gered.  See epoll(7) for more detailed information about edge-         triggered and level-triggered notification.         This flag is an input flag for the event.events field when         calling epoll_ctl(); it is never returned by epoll_wait(2).  EPOLLONESHOT (since Linux 2.6.2)         Requests one-shot notification for the associated file de‐         scriptor.  This means that after an event notified for the         file descriptor by epoll_wait(2), the file descriptor is dis‐         abled in the interest list and no other events will be re‐         ported by the epoll interface.  The user must call epoll_ctl()         with EPOLL_CTL_MOD to rearm the file descriptor with a new         event mask.         This flag is an input flag for the event.events field when         calling epoll_ctl(); it is never returned by epoll_wait(2).</code></pre></blockquote><p>可以注意到，和SelectionKey中的事件有一些差别，比如这里没有OP_ACCEPT和OP_CONNECT。那么这两个事件是做什么的🤔？</p><h2 id="ACCEPT"><a href="#ACCEPT" class="headerlink" title="ACCEPT"></a>ACCEPT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateInterestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newOps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>)</span><br><span class="line">        newOps |= Net.POLLIN;</span><br><span class="line">    <span class="keyword">return</span> newOps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OP_ACCEPT变成了Net.POLLIN。而对于<code>CONNECT</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateInterestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newOps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; SelectionKey.OP_READ) != <span class="number">0</span>)</span><br><span class="line">        newOps |= Net.POLLIN;</span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>)</span><br><span class="line">        newOps |= Net.POLLOUT;</span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>)</span><br><span class="line">        newOps |= Net.POLLCONN;</span><br><span class="line">    <span class="keyword">return</span> newOps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POLLCONN和POLLOUT一样均为4，通过socket的状态进行区分。如果socket未连接代表OP_CONNECT,已连接代表OP_WRITE。如果说把POLLIN拆分成ACCEPT和READ尚可理解，那把OUT拆成WRITE和CONNECT是为什么？</p><h2 id="OP-CONNECT是在做什么"><a href="#OP-CONNECT是在做什么" class="headerlink" title="OP_CONNECT是在做什么"></a>OP_CONNECT是在做什么</h2><p>这里有一个非常容易误解的地方，客户端调用connect,服务端调触发OP_ACCEPT事件，调用accept之后客户端触发OP_CONNECT事件，调用finishConnect。看上去和三次握手完全一致，但完全不是那回事，通过wireshark调试得知在服务端调用accept时三次握手已经完成了。那么OP_CONNECT和finishConnect分别是在做什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> polled = Net.pollConnectNow(fd);</span><br></pre></td></tr></table></figure><p>这是一个native方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jint fd = fdval(env, fdo);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">poller</span>;</span></span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">poller.fd = fd;</span><br><span class="line">poller.events = POLLOUT;</span><br><span class="line">poller.revents = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (timeout &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">    timeout = <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout &gt; INT_MAX) &#123;</span><br><span class="line">    timeout = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">result = poll(&amp;poller, <span class="number">1</span>, (<span class="keyword">int</span>)timeout);</span><br></pre></td></tr></table></figure><p>可以看到jni方法只是在用poll()检查该fd的POLLOUT事件。而POLLOUT表示socket缓冲区可写，隐含连接已经建立。所以对于阻塞的finishConnect()，他会阻塞到连接建立，而非阻塞的finishConnect，用返回值代表连接是否建立。这个方法名很有误导性，<del>建议改为doesItFinishConnect</del>，或者说非阻塞的connect好像用处不大。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>epoll事件转换为NIO事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">translateReadyOps</span><span class="params">(<span class="keyword">int</span> ops, <span class="keyword">int</span> initialOps,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 SelectionKeyImpl sk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intOps = sk.nioInterestOps(); <span class="comment">// Do this just once, it synchronizes</span></span><br><span class="line">    <span class="keyword">int</span> oldOps = sk.nioReadyOps();</span><br><span class="line">    <span class="keyword">int</span> newOps = initialOps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; Net.POLLNVAL) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This should only happen if this channel is pre-closed while a</span></span><br><span class="line">        <span class="comment">// selection operation is in progress</span></span><br><span class="line">        <span class="comment">// ## Throw an error if this channel has not been pre-closed</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != <span class="number">0</span>) &#123;</span><br><span class="line">        newOps = intOps;</span><br><span class="line">        sk.nioReadyOps(newOps);</span><br><span class="line">        <span class="comment">// No need to poll again in checkConnect,</span></span><br><span class="line">        <span class="comment">// the error will be detected there</span></span><br><span class="line">        readyToConnect = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> (newOps &amp; ~oldOps) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((ops &amp; Net.POLLIN) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        ((intOps &amp; SelectionKey.OP_READ) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (state == ST_CONNECTED))</span><br><span class="line">        newOps |= SelectionKey.OP_READ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((ops &amp; Net.POLLCONN) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        ((intOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        ((state == ST_UNCONNECTED) || (state == ST_PENDING))) &#123;</span><br><span class="line">        newOps |= SelectionKey.OP_CONNECT;</span><br><span class="line">        readyToConnect = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((ops &amp; Net.POLLOUT) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        ((intOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (state == ST_CONNECTED))</span><br><span class="line">        newOps |= SelectionKey.OP_WRITE;</span><br><span class="line"></span><br><span class="line">    sk.nioReadyOps(newOps);</span><br><span class="line">    <span class="keyword">return</span> (newOps &amp; ~oldOps) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出：</p><ol><li><p>POLLNVAL没有设置任何ReadyOps，POLLNAVAL的值为32，在上表中没有对应的项。如注释所说，应该是API使用错误不去管他。</p></li><li><p>POLLERR和ROLLHUP原封不动复制了intOps，也就是会<strong>触发所有注册的事件</strong>。</p></li></ol><p>这里还翻到Netty的一个issue<a href="https://github.com/netty/netty/issues/924">https://github.com/netty/netty/issues/924</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line">    <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">    ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">    unsafe.finishConnect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line"><span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">    ch.unsafe().forceFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line"><span class="comment">// to a spin loop</span></span><br><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">    unsafe.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netty的OP_CONNECT处理在第一位，当对方发送Reset时，首先会进入unsafe.finishConnect()，而这里并没有取消事件也没有关闭连接的逻辑。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>注意到上面代码的最后一行，Java把IN事件分离成ACCEPT和READ，但是Netty又把ACCEPT和READ统一起来，ServerSocket的读处理就是调用Accept:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Failed to create a new channel from an accepted socket.&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Failed to close a socket.&quot;</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个事情的感觉就是都有自己这么做的理由，但是组合起来就十分滑稽。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nio在linux对应的实现是epoll。在linux中，所有I/O都抽象为文件（包括网络和文件读写)，用文件描述符（fd）来标识。fd是一个非负整数， 其中0，1，2分别对应&lt;code&gt;stdin&lt;/code&gt;，&lt;code&gt;stdout&lt;/code&gt;，&lt;code&gt;stde
      
    
    </summary>
    
      <category term="java" scheme="https://ezksd.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java标准库中一处不太合理的地方</title>
    <link href="https://ezksd.github.io/2020/08/05/generic-heap/"/>
    <id>https://ezksd.github.io/2020/08/05/generic-heap/</id>
    <published>2020-08-05T20:44:34.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><del>众所周知</del>，Java的泛型非常拉稀。虽然我认为在表达能力差不多的情况下，别的都可以忍忍。Java的表达能力差在哪里呢：</p><ol><li><p>不能创建泛型数组<br> 可以用Object[]加强制转型，与此同时方法还要加上@SuppressWarnings(“unchecked”)，不然会有编译期警告。</p></li><li><p>不能通过泛型创建对象<br> 可以把Class&lt;T&gt;作为参数，在内部用反射调构造函数。这种情况非常普遍，但在Java8或以上版本中并不合适。我们可以把参数Class&lt;T&gt;改为Supplier&lt;T&gt;，讲究一点可以写成Supplier&lt;? extends T&gt;，然后调用的时候传入构造器方法引用。（目前还想不出特别好的例子展示这两者的区别，想到再补）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">construct</span><span class="params">(Supplier&lt;? extends E&gt; sup)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sup.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = construct(String::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 举一个netty的例子：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">b.group(group)</span><br><span class="line"> .channel(NioSocketChannel.class) <span class="comment">// 看这里</span></span><br><span class="line"> .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line"> .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         ChannelPipeline p = ch.pipeline();</span><br><span class="line">         <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">             p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));</span><br><span class="line">         &#125;</span><br><span class="line">         p.addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p> 而channel函数是这么定义的：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里ChannelFactory等价于Supplier&lt;T extends Channel&gt;，<br> 只需要用channelFactory(NioSocketChannel::new)就可以了。::new还比.class少一个字符，在java9以上版本反射可能会出现微妙的问题，而反射唯一的优点是能调用私有的构造函数。</p></li><li><p>不支持协变逆变，或者说以一个难看的方式支持部分协变逆变</p></li><li><p><del>暂时没有第四</del></p></li></ol><h2 id="可变性-协变-逆变"><a href="#可变性-协变-逆变" class="headerlink" title="可变性(协变/逆变)"></a>可变性(协变/逆变)</h2><p>Java的可变性和其他语言(比如Scala, C#)里最大的区别在于Java的可变性在使用的时候标明(比如声明一个变量，代入类型参数)，而其他语言在定义类/接口/特质的时候标明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;? extends A&gt; collections = ...;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span>[+<span class="type">A</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>标准库里的PriorityQueue&lt;E&gt;，也就是我们常说的堆，定义是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">final</span> <span class="title">Comparator</span>&lt;? <span class="title">super</span> <span class="title">E</span>&gt; <span class="title">comparator</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看这里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] es)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x; </span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = es[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            es[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        es[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码的意思是，可以手动指定Comparator，如果T本身是Comparable的子类型的话也可以不用指定，此时comparator为空，比较的时候会强制转型为Comparable。但是如果这个时候我不小心创建了一个没有实现Comparable的优先级队列，编译期不会有任何问题，运行的时候就炸了。<del>也太不小心了</del><br>但是其实是可以在编译期避免这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> E&gt; comp;</span><br><span class="line">    E[] array;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Heap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comp, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comp = comp;</span><br><span class="line">        <span class="keyword">this</span>.array = (E[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">Heap&lt;E&gt; <span class="title">newHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newHeap(Comparable::compareTo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;E&gt; <span class="function">Heap&lt;E&gt; <span class="title">newHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newHeap(comp,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;E&gt; <span class="function">Heap&lt;E&gt; <span class="title">newHeap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comp, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Heap&lt;&gt;(comp,size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里是静态方法，因为用构造器的话行不通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h2&gt;&lt;p&gt;&lt;del&gt;众所周知&lt;/del&gt;，Java的泛型非常拉稀。虽然我认为在表达能力差不多的情况下，别的都可以忍忍。Java的表达能力差在哪里呢：&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://ezksd.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 14 特性简介</title>
    <link href="https://ezksd.github.io/2020/06/23/java-14/"/>
    <id>https://ezksd.github.io/2020/06/23/java-14/</id>
    <published>2020-06-23T10:00:00.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<p>java 14出来已经有一段时间了，相比之前的小幅更新，这一次的新增语法特性还是比较多的。而且前面的众多特性，包括14中的部分特性都是为模式匹配做准备，基本上就差临门一脚了。本文将仅对新增语法特性做一个简单介绍。</p><h2 id="305-Pattern-Matching-for-instanceof-Preview"><a href="#305-Pattern-Matching-for-instanceof-Preview" class="headerlink" title="305: Pattern Matching for instanceof (Preview)"></a>305: Pattern Matching for instanceof (Preview)</h2><p>这是一个preview特性，需要编译的时候加上<code>--enable-preview</code>参数，同时还要指定<code>--release</code>或者<code>--source</code>，仅作尝鲜使用。</p><p>这个特性本身的作用是简化<code>instance of</code>的使用，因为如果<code>instance of</code>为真，那么之后的强制转型就显得很多余。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String) obj;</span><br><span class="line">    <span class="comment">// use s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// can use s here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// can&#x27;t use s here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，新的语法<code>instance of</code>类型之后多了一个变量，这也是唯一的区别。虽然他看上去仍然去有点多余，为什么不在对应的作用域内obj的类型直接就当成String呢。我猜测是这个特性为了和后续的模式匹配的解构风格保持一致，毕竟这个特性本身就是为模式匹配铺路的。</p><h2 id="359-Records-Preview"><a href="#359-Records-Preview" class="headerlink" title="359:    Records (Preview)"></a>359:    Records (Preview)</h2><p>这依然是一个preview特性，它很像c的结构体，但准确来讲它更像scala的case class。加上JEP 360: Sealed Classes (Preview)之后，就等于支持代数数据类型了，当然目前也差不多可以用了，差别是模式匹配的时候编译器能否判断代码有没有把所有的可能性写全。抛开这些，Record可以视为一个语法糖，因为他编译之后可以还原成一个等价的class。利用这个特性，我们可以少写很多代码，因为record可以自动生成：构造器，get方法，<code>toString</code>，<code>hashCode</code>，<code>equals</code>方法，<strong>注意</strong>：这里并没有set方法，因为record默认是不可变的。而且record可以实现接口，但是不能继承其他类，同时除此以外和一个普通的class没有什么差别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>语法如上，因为record还能添加自定义构造器和实现方法，为了保持一致还是保留了大括号（虽然看上去很多余）．</p><h2 id="JEP-361-Switch-Expressions-Standard"><a href="#JEP-361-Switch-Expressions-Standard" class="headerlink" title="JEP 361: Switch Expressions (Standard)"></a>JEP 361: Switch Expressions (Standard)</h2><p>这个之前就有，不过在java 14中不再是preview特性了，简单将，switch语句是一个表达式，它是有值的．当然语法和switch statement有一些差别．</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并没有体现出switch expressions是一个表达式，与switch statement的最大差别是他没有fall through特性，不需要到处加break了．</p><p>王垠曾经讲：访问者模式只是模式匹配丑陋的模仿(大意)．观点正确与否暂且不论，模式匹配和观察者模式的确有很多共同之处．比如一个访问者接口的定义(以遍历二叉树为例)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Node n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Leaf l)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>haskell</code>的模式匹配定义如出一辙</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">visit</span> :: <span class="type">Tree</span> e -&gt;　()</span><br><span class="line"><span class="title">visit</span> (<span class="type">Node</span> n) = ...</span><br><span class="line"><span class="title">visit</span> (<span class="type">Leaf</span> f) = ...</span><br></pre></td></tr></table></figure><p>虽然这些语法离完整的模式匹配还差一脚，不过已经差不多够了，接下来就用新的语法写一个简单的计算器．</p><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>首先是token的定义。scala中有与case class对应的cass object，也就是单例的record。不过java目前还没有，用enum代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Token</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Number</span><span class="params">(<span class="keyword">int</span> i)</span> implements Token</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Operator</span> <span class="keyword">implements</span> <span class="title">Token</span></span>&#123;</span><br><span class="line">    ADD,MINUS,MULTIPLY,DIVIDED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Bracket</span> <span class="keyword">implements</span> <span class="title">Token</span></span>&#123;</span><br><span class="line">    LEFT,RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于java标准库中没有tuple，再加一个tuple，用来当多返回值，同时返回token和所在的位置．</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">record Tuple&lt;A,B&gt;(A a,B b)&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后是parser部分，省去了tokenizer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Optional&lt;List&lt;Token&gt;&gt; parseAll(String s) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> LinkedList&lt;Token&gt;();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = parse(s, i);</span><br><span class="line">        <span class="keyword">if</span> (r.isPresent()) &#123;</span><br><span class="line">            list.add(r.get().a());</span><br><span class="line">            i = r.get().b();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Optional&lt;Tuple&lt;Token, Integer&gt;&gt; parse(String s, <span class="keyword">int</span> p) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = s.charAt(p);</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span> -&gt; Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(Bracket.LEFT, p + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> -&gt; Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(Bracket.RIGHT, p + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> -&gt; Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(Operator.MULTIPLY, p + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> -&gt; Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(Operator.DIVIDED, p + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> -&gt; Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(Operator.ADD, p + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> -&gt; Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(Operator.MINUS, p + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">default</span> -&gt; parseNumber(s, p);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Optional&lt;Tuple&lt;Token, Integer&gt;&gt; parseNumber(String s, <span class="keyword">int</span> p) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Character.isDigit(s.charAt(p)))&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(p))) &#123;</span><br><span class="line">        i = i * <span class="number">10</span> + (s.charAt(p++) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(<span class="keyword">new</span> Number(i), p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是解释部分，左递归消除就不赘述了，简单说下文法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr = term expr1</span><br><span class="line">expr1 = (+/-) term expr1 | ε</span><br><span class="line">term = digit | term1</span><br><span class="line">term1 = (*//) digit term1 | ε</span><br><span class="line">digit = 整数 | <span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Optional&lt;Tuple&lt;Double,Integer&gt;&gt; expr(List&lt;Token&gt; list,<span class="keyword">int</span> p)&#123;</span><br><span class="line">      <span class="keyword">var</span> term = term(list, p);</span><br><span class="line">      <span class="keyword">return</span> term.flatMap(x -&gt;&#123;</span><br><span class="line">          <span class="keyword">var</span> tuples = expr1(list, x.b());</span><br><span class="line">          <span class="keyword">return</span> tuples.map(xs -&gt; &#123;</span><br><span class="line">              <span class="keyword">double</span> s = x.a();</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">var</span> tuple : xs.a()) &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (tuple.a()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> ADD -&gt; s += tuple.b();</span><br><span class="line">                      <span class="keyword">case</span> MINUS -&gt; s -= tuple.b();</span><br><span class="line">                      <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Tuple&lt;&gt;(s, xs.b());</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Optional&lt;Tuple&lt;List&lt;Tuple&lt;Operator, Double&gt;&gt;, Integer&gt;&gt; expr1(List&lt;Token&gt; list, <span class="keyword">int</span> p)&#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="keyword">new</span> LinkedList&lt;Tuple&lt;Operator,Double&gt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (p &lt; list.size()) &#123;</span><br><span class="line">          <span class="keyword">var</span> token = list.get(p);</span><br><span class="line">          <span class="keyword">var</span> term = term(list, p + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span>(term.isPresent() &amp;&amp; (token == Operator.ADD || token == Operator.MINUS))&#123;</span><br><span class="line">              result.add(<span class="keyword">new</span> Tuple&lt;&gt;((Operator)token, term.get().a()));</span><br><span class="line">              p = p + <span class="number">2</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(result, p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Optional&lt;Tuple&lt;Double,Integer&gt;&gt; term(List&lt;Token&gt; list,<span class="keyword">int</span> p)&#123;</span><br><span class="line">      <span class="keyword">var</span> digit = digit(list, p);</span><br><span class="line">      <span class="keyword">return</span> digit.flatMap(x -&gt; &#123;</span><br><span class="line">          <span class="keyword">var</span> tuples = term1(list, x.b());</span><br><span class="line">          <span class="keyword">return</span> tuples.map(xs -&gt; &#123;</span><br><span class="line">              <span class="keyword">double</span> s = x.a();</span><br><span class="line">              <span class="keyword">for</span> (Tuple&lt;Operator, Double&gt; tuple : xs.a()) &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (tuple.a()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> MULTIPLY -&gt; s *= tuple.b();</span><br><span class="line">                      <span class="keyword">case</span> DIVIDED -&gt; s /= tuple.b();</span><br><span class="line">                      <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Tuple&lt;&gt;(s,xs.b());</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Optional&lt;Tuple&lt;List&lt;Tuple&lt;Operator,Double&gt;&gt;,Integer&gt;&gt; term1(List&lt;Token&gt; list,<span class="keyword">int</span> p)&#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="keyword">new</span> LinkedList&lt;Tuple&lt;Operator,Double&gt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (p &lt; list.size()) &#123;</span><br><span class="line">          <span class="keyword">var</span> token = list.get(p);</span><br><span class="line">          <span class="keyword">var</span> term = digit(list, p + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span>(term.isPresent() &amp;&amp; (token == Operator.MULTIPLY || token == Operator.DIVIDED))&#123;</span><br><span class="line">              result.add(<span class="keyword">new</span> Tuple&lt;&gt;((Operator)token, term.get().a()));</span><br><span class="line">              p = p + <span class="number">2</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(result, p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Optional&lt;Tuple&lt;Double, Integer&gt;&gt; digit(List&lt;Token&gt; list, <span class="keyword">int</span> p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p &lt; list.size())&#123;</span><br><span class="line">          <span class="keyword">var</span> t = list.get(p);</span><br><span class="line">          <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Number)</span><br><span class="line">              <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(((<span class="keyword">double</span>) ((Number) list.get(p)).i()), p + <span class="number">1</span>));</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(t == Bracket.LEFT)&#123;</span><br><span class="line">              <span class="keyword">return</span> expr(list, p + <span class="number">1</span>).flatMap(x -&gt; &#123;</span><br><span class="line">                  <span class="keyword">if</span> (x.b() &lt; list.size() &amp;&amp; list.get(x.b()) == Bracket.RIGHT) &#123;</span><br><span class="line">                      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> Tuple&lt;&gt;(x.a(), x.b() + <span class="number">1</span>));</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> Optional.empty();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Optional.empty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后返回的是值和字符所在位置的tuple，再加一个包装函数就完工了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Optional&lt;Double&gt; <span class="title">caculate</span><span class="params">(List&lt;Token&gt; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;Token&gt;(tokens.size());</span><br><span class="line">    list.addAll(tokens);</span><br><span class="line">    <span class="keyword">return</span> expr(list,<span class="number">0</span>).map(Tuple::a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码在<a href="https://gist.github.com/ezksd/fc3da994c668abbabebb6a08e2fa1e9a">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java 14出来已经有一段时间了，相比之前的小幅更新，这一次的新增语法特性还是比较多的。而且前面的众多特性，包括14中的部分特性都是为模式匹配做准备，基本上就差临门一脚了。本文将仅对新增语法特性做一个简单介绍。&lt;/p&gt;
&lt;h2 id=&quot;305-Pattern-Matchi
      
    
    </summary>
    
      <category term="java" scheme="https://ezksd.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust的缺点</title>
    <link href="https://ezksd.github.io/2019/06/02/rust/"/>
    <id>https://ezksd.github.io/2019/06/02/rust/</id>
    <published>2019-06-02T19:17:15.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<p>这世界有太多的传教士了，比如<strong>一部分</strong>Haskell传教士会拿一个两行的快排，但是不告诉你那不是原地排序，而等价的原地排序可能比java还长。</p><p>那Rust真的有传教士说的那么美吗，是否遗漏了什么。</p><h2 id="trait不是类型，同时也不支持子类型"><a href="#trait不是类型，同时也不支持子类型" class="headerlink" title="trait不是类型，同时也不支持子类型"></a>trait不是类型，同时也不支持子类型</h2><p>当然，这可能是设计需要，但让人难受但地方，我先把他归类为缺点。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>(a: <span class="built_in">Ord</span>,b: <span class="built_in">Ord</span>) -&gt; <span class="built_in">bool</span>&#123;</span><br><span class="line">    a &lt; b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0038]: the trait `std::cmp::Ord` cannot be made into an object</span><br><span class="line"> --&gt; src/main.rs:2:15</span><br><span class="line">  |</span><br><span class="line">2 | fn compare(a: Ord,b: Ord) -&gt; bool&#123;</span><br><span class="line">  |               ^^^ the trait `std::cmp::Ord` cannot be made into an object</span><br><span class="line">  |</span><br><span class="line">  = note: the trait cannot use `Self` as a <span class="built_in">type</span> parameter <span class="keyword">in</span> the supertraits or where-clauses</span><br></pre></td></tr></table></figure><p>不过你可以用类型推导，这里要求该类型实现了<code>Ord</code> trait， 于是我们就可以用<code>&lt;</code>来比较了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>&lt;A:<span class="built_in">Ord</span>&gt;(a: A,b: A) -&gt; <span class="built_in">bool</span>&#123;</span><br><span class="line">    a &lt; b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与子类型有本质的区别，比如在返回值位置就没办法这么写了。返回值在函数内部已经给出，推导的时候就对不上了。</p><blockquote><p>再愛你，依然是兩個人～</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">compare</span></span>&lt;A:<span class="built_in">Ord</span>&gt;() -&gt; A&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:3:5</span><br><span class="line">  |</span><br><span class="line">2 | fn compare&lt;A:Ord&gt;() -&gt; A&#123;</span><br><span class="line">  |                        - expected `A` because of <span class="built_in">return</span> <span class="built_in">type</span></span><br><span class="line">3 |     1</span><br><span class="line">  |     ^ expected <span class="built_in">type</span> parameter, found <span class="built_in">integer</span></span><br><span class="line">  |</span><br><span class="line">  = note: expected <span class="built_in">type</span> `A`</span><br><span class="line">             found <span class="built_in">type</span> `&#123;<span class="built_in">integer</span>&#125;`</span><br></pre></td></tr></table></figure><p>不是所有的值都有一个明确的类型，比如闭包，这个时候就要存在类型：</p><blockquote><p>世界上没有两片相同的叶子，Rust里也没有两个的闭包</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">counter</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>() -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i = <span class="number">0</span>;</span><br><span class="line">    || &#123;</span><br><span class="line">        <span class="keyword">let</span> r = i;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此同时存在类型是一个非常难用的东西，他对应存在量词<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.258ex" height="1.57ex" role="img" focusable="false" viewBox="0 -694 556 694" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-2203" d="M56 661T56 674T70 694H487Q497 686 500 679V15Q497 10 487 1L279 0H70Q56 7 56 20T70 40H460V327H84Q70 334 70 347T84 367H460V654H70Q56 661 56 674Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="2203" xlink:href="#MJX-1-TEX-N-2203"></use></g></g></g></svg></mjx-container>，而范型对应全称量词<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.258ex" height="1.62ex" role="img" focusable="false" viewBox="0 -694 556 716" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-2200" d="M0 673Q0 684 7 689T20 694Q32 694 38 680T82 567L126 451H430L473 566Q483 593 494 622T512 668T519 685Q524 694 538 694Q556 692 556 674Q556 670 426 329T293 -15Q288 -22 278 -22T263 -15Q260 -11 131 328T0 673ZM414 410Q414 411 278 411T142 410L278 55L414 410Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="2200" xlink:href="#MJX-1-TEX-N-2200"></use></g></g></g></svg></mjx-container>。</p><h2 id="延时求值"><a href="#延时求值" class="headerlink" title="延时求值"></a>延时求值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>听上去很美，但假设他不做所谓的延时求值，甚至都没有办法抽象出来一套东西。</p><p>比如map方法并没有立刻转换，而是直接把原来的Iterator和函数包在了结构体里：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) -&gt; Map&lt;<span class="keyword">Self</span>, F&gt; <span class="keyword">where</span></span><br><span class="line"><span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="built_in">FnMut</span>(Self::Item) -&gt; B,</span><br><span class="line">&#123;</span><br><span class="line">  Map::new(<span class="keyword">self</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如你想把他的返回值改成<code>Iterator&lt;Item=B&gt;</code>是编译不过的，因为trait不是类型。这里需要一个具体的类型，比如结构体或者枚举，于是你会看到大量这样的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">step_by</span></span>(<span class="keyword">self</span>, step: <span class="built_in">usize</span>) -&gt; StepBy&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">chain</span></span>&lt;U&gt;(<span class="keyword">self</span>, other: U) -&gt; Chain&lt;<span class="keyword">Self</span>, U::IntoIter&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">zip</span></span>&lt;U&gt;(<span class="keyword">self</span>, other: U) -&gt; Zip&lt;<span class="keyword">Self</span>, U::IntoIter&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) -&gt; Map&lt;<span class="keyword">Self</span>, F&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">filter</span></span>&lt;P&gt;(<span class="keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="keyword">Self</span>, P&gt;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">enumerate</span></span>(<span class="keyword">self</span>) -&gt; Enumerate&lt;<span class="keyword">Self</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">peekable</span></span>(<span class="keyword">self</span>) -&gt; Peekable&lt;<span class="keyword">Self</span>&gt;</span><br></pre></td></tr></table></figure><p>每定义一个新的方法，你就需要定义一个新的结构体（因为你不能在同一个结构体上实现同一个trait两次），然后再在结构体上实现trait的方法。这种代码风格Java程序员一定很熟悉，我把他称为实名内部类。如果比Iterator官方实现的代码长度，Rust肯定是首屈一指的。</p><p>如果只是代码长倒不是很大的问题，毕竟我是一名Java程序员。</p><p>再看一个具体一点的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">flat_map</span></span>&lt;U, F&gt;(<span class="keyword">self</span>, f: F) -&gt; FlatMap&lt;<span class="keyword">Self</span>, U, F&gt;</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, U: <span class="built_in">IntoIterator</span>, F: <span class="built_in">FnMut</span>(Self::Item) -&gt; U,</span><br><span class="line">&#123;</span><br><span class="line">    FlatMap::new(<span class="keyword">self</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>F</code>（这里代表一个函数）的返回值类型<code>U</code>是根据类型推导来的，这就造成一个问题，假如函数中有if else或者模式匹配这样的分支，两个分支的类型会对不上。注意这里如果不用return，if表达式的类型就已经对不上了（在Rust中if else是一个表达式，和Scala类似）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> j = (<span class="number">1</span>..<span class="number">9</span>).flat_map(|x|&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec!</span>[x].iter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).collect();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:8:16</span><br><span class="line">  |</span><br><span class="line">8 |         return vec![x].iter();</span><br><span class="line">  |                ^^^^^^^^^^^^^^ expected struct `std::iter::Empty`, found struct `std::slice::Iter`</span><br><span class="line">  |</span><br><span class="line">  = note: expected type `std::iter::Empty&lt;_&gt;`</span><br><span class="line">             found type `std::slice::Iter&lt;&#x27;_, &#123;integer&#125;&gt;`</span><br></pre></td></tr></table></figure><p>假如你的代码里出现了分支，其中一个用的map,另外一个用的filter,那他类型是对不上的，甚至于说都是map,闭包的类型也对不上（闭包是Map的类型参数）。</p><blockquote><p>如果你听说Rust支持type class，想来搞点函数式，你是否搞错了什么？</p></blockquote><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>你不要把FP那套东西搞过来，同时也不要OOP那套东西搞过来，Rust就是Rust。</p></blockquote><p>Rust可以用trait object来表达多态，但是编译器需要在编译期知道函数的参数、局部变量的大小，所以这里必须套上一个引用或者Box。而且编译器对trait object有额外的限制：</p><blockquote><p>Object Safety Is Required for Trait Objects<br>You can only make object-safe traits into trait objects. Some complex rules govern all the properties that make a trait object safe, but in practice, only two rules are relevant. A trait is object safe if <strong>all the methods</strong> defined in the trait have the following properties:</p><ul><li>The return type isn’t Self.</li><li>There are no generic type parameters.</li></ul></blockquote><p><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a></p><p><strong>所有的</strong>方法都不能有泛型参数，零<del>成本</del>抽象。不过在老一点的文档里有另外一条，这一点我也认为非常坑爹，Rust的文档散落在世界的各个角落里。</p><blockquote><p>你渴望力量吗？</p></blockquote><p><a href="https://doc.rust-lang.org/book/title-page.html">https://doc.rust-lang.org/book/title-page.html</a></p><p><a href="https://doc.rust-lang.org/edition-guide/rust-2018/index.html">https://doc.rust-lang.org/edition-guide/rust-2018/index.html</a></p><p><a href="https://doc.rust-lang.org/1.19.0/book/first-edition/README.html">https://doc.rust-lang.org/1.19.0/book/first-edition/README.html</a></p><p>在<strong>老版</strong>的Rust Book里面关于object safety有更详细的描述：</p><blockquote><p>The error says that <code>Clone</code> is not ‘object-safe’. Only traits that are object-safe can be made into trait objects. A trait is object-safe if both of these are true:</p><ul><li>the trait does not require that <code>Self: Sized</code></li><li>all of its methods are object-safe</li></ul><p>So what makes a method object-safe? Each method must require that <code>Self: Sized</code> or all of the following:</p><ul><li>must not have any type parameters</li><li>must not use <code>Self</code></li></ul></blockquote><p>Each method must require that <code>Self: Sized</code> <strong>or</strong> all of the following…</p><p>新版不仅把这句话删了，我不知道是怎么想的。这里可以理解为加了<code>Self: Sized</code> 就可以绕过这个限制，与此同时trait object就不能再调用这个方法了，<del>欲练此功，必先自宫</del>。</p><p>依据这一条，我们可以这样来定义Iterator。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; E;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">flat_map</span></span>&lt;B,F&gt;(<span class="keyword">self</span>,f: F) -&gt; FlatMap&lt;<span class="keyword">Self</span>,F&gt; </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>,F: <span class="built_in">Fn</span>(E) -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Iterator</span>&lt;B&gt;&gt;&#123;</span><br><span class="line">        Map(<span class="keyword">self</span>,f)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点就是你需要在各种地方套Box。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>叔叔，叔叔，听说你们这个语言写不了链表是吗？</p></blockquote><p>Rust的引用规则很简单：可变引用可以同时存在多个，不可以引用同时只能存在一个，而可变引用存在的时候不能创建不可变引用。</p><p>常见的链表next是一个可变引用，tail指针也是可变的，他们同时指向链表的最后一个节点，这是Rust绕不过去的坎。</p><p>规则简单，不代表他用起来容易。你可以看到这个规则，就马上想到Rust不用unsafe无法实现链表，然后享受一个周末而不是和编译器死磕吗？</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote><p>王垠：rust所谓的生命周期就是把引用计数限制为1，那处理起来当然简单了。</p></blockquote><p>不得不佩服王垠的敏锐，那么这句话要如何理解呢？因为看上去rust允许多个不可变引用。</p><p>这也是生命周期的设计理念，引用的生命周期被包含在值的生命周期内，所以他可以直接忽略，由所有者负责释放，而所有者就是那个1。这也是为什么你想在线程之间传引用通常是一个错误的选择。</p><p>而可变引用的不同之处在于，假如把引用指向另外一个值，他需要释放前一个值。</p><blockquote><p>这都不知道？再去看看TRPL吧，都在里面。</p></blockquote><h2 id="TRPL"><a href="#TRPL" class="headerlink" title="TRPL"></a>TRPL</h2><p>说到这里就不得不提<code>The Rust Programming Language</code>，Rust吹们把他简称为TRPL以示尊敬。你必须知道它，同时也必须知道这个缩写。</p><p>那么TRPL，有没有那么详细？显然是没有的，首先他相对于老的文档做过一定的删减，比如上面提到的trait object。那回到正题，我认为这篇文档漏掉了一个相当重要的东西就是<code>std::mem::replace</code>，Option里把他包装成<code>take</code>。他的作用是把旧的值取出来，同时给一个新值。这样我们就可以对原来的值随意操作了。我认为在你知道这个东西之前，你可能至少会浪费一个星期尝试去对可变引用做模式匹配，直到你知道有这个东西，或者精通unsafe。</p><p>比如，假如我想把栈顶取出来，然后向后挪一位，可能会这么实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Stack</span></span>&lt;E&gt; &#123;</span><br><span class="line">    More(E,<span class="built_in">Box</span>&lt;Stack&lt;E&gt;&gt;),</span><br><span class="line">    Less</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;E&gt; Stack&lt;E&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Stack&lt;E&gt;&#123;</span><br><span class="line">        Stack::Less</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Stack::More(item,next) =&gt; &#123;</span><br><span class="line">                *<span class="keyword">self</span> = **next;</span><br><span class="line">                <span class="literal">Some</span>(*item)</span><br><span class="line">            &#125;,</span><br><span class="line">            Stack::Less =&gt; <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你显然犯了错误，self可变引用存在的同时，模式匹配会创建新的引用。那有了replace，就可以这样写。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = std::mem::replace(<span class="keyword">self</span>, Stack::Less);</span><br><span class="line">    <span class="keyword">match</span> pre &#123;</span><br><span class="line">        Stack::More(item,next) =&gt; &#123;</span><br><span class="line">            *<span class="keyword">self</span> = *next;</span><br><span class="line">            <span class="literal">Some</span>(item)</span><br><span class="line">        &#125;,</span><br><span class="line">        Stack::Less =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这显然不够<strong>零成本抽象</strong>，因为Less是一个垃圾值，随后就会被释放掉。当然你也可以用unsafe。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">unsafe</span>&#123;std::ptr::read(<span class="keyword">self</span>)&#125; &#123;</span><br><span class="line">        Stack::More(item,next) =&gt; &#123;</span><br><span class="line">            <span class="keyword">unsafe</span>&#123;std::ptr::write(<span class="keyword">self</span>, *next)&#125;</span><br><span class="line">            <span class="literal">Some</span>(item)</span><br><span class="line">        &#125;,</span><br><span class="line">        Stack::Less =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>什么，竟然有人在用unsafe? unsafe 警察，出警👮‍♀️！</p></blockquote><h2 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h2><blockquote><p>很多人以为Rust学习成本很高，他只不过把复杂的部分都暴露出来了。</p></blockquote><p>不，Rust的学习成本比你想象的还要高。不仅仅是学习语法，而是花大量但时间总结在这一套限制之下该如何写代码。正如同学习如何戴着镣铐跳舞💃💃💃。</p><p>那么Rust值得吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这世界有太多的传教士了，比如&lt;strong&gt;一部分&lt;/strong&gt;Haskell传教士会拿一个两行的快排，但是不告诉你那不是原地排序，而等价的原地排序可能比java还长。&lt;/p&gt;
&lt;p&gt;那Rust真的有传教士说的那么美吗，是否遗漏了什么。&lt;/p&gt;
&lt;h2 id=&quot;trai
      
    
    </summary>
    
      <category term="rust" scheme="https://ezksd.github.io/categories/rust/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义Zsh主题</title>
    <link href="https://ezksd.github.io/2019/05/06/custom-zsh-theme/"/>
    <id>https://ezksd.github.io/2019/05/06/custom-zsh-theme/</id>
    <published>2019-05-06T23:45:44.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<p>一直在用zsh的主题ys。一直有一个很烦的问题，刚进入shell的时候最上面有一个空行看起来十分难受。<br>今天想起来解决了一下，发现并不困难。</p><p>zsh的主题就是一个shell文件，修改变量PROMT就好了，而ys这个主题<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/themes/ys.zsh-theme">ys.zsh-theme</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PROMPT=&quot;</span><br><span class="line"><span class="meta">%</span><span class="bash">&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;<span class="comment">#%&#123;$reset_color%&#125; \</span></span></span><br><span class="line"><span class="bash">%(<span class="comment">#,%&#123;$bg[yellow]%&#125;%&#123;$fg[black]%&#125;%n%&#123;$reset_color%&#125;,%&#123;$fg[cyan]%&#125;%n) \</span></span></span><br><span class="line"><span class="bash">%&#123;<span class="variable">$fg</span>[white]%&#125;@ \</span></span><br><span class="line"><span class="bash">%&#123;<span class="variable">$fg</span>[green]%&#125;%m \</span></span><br><span class="line"><span class="bash">%&#123;<span class="variable">$fg</span>[white]%&#125;<span class="keyword">in</span> \</span></span><br><span class="line"><span class="bash">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;%~%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="bash"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="bash"><span class="variable">$&#123;git_info&#125;</span>\</span></span><br><span class="line"><span class="bash"> \</span></span><br><span class="line"><span class="bash">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*] <span class="variable">$exit_code</span></span></span><br><span class="line"><span class="meta">%</span><span class="bash">&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;$ %&#123;<span class="variable">$reset_color</span>%&#125;<span class="string">&quot;</span></span></span><br></pre></td></tr></table></figure><p>在开头的时候就加了一个换行，把他去掉命令之间又太紧凑了。而<code>PROMT</code>是一个变量，赋值是一次性的，在里面插一个带状态的函数又行不通。</p><p>好在文档里有一个函数<a href="http://zsh.sourceforge.net/Doc/Release/Functions.html"><code>precmd</code></a>，接下来就很简单了，把这个插入到要修改的主题，再把<code>PROMPT</code>再把前面的换行删掉就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local prompt_prefix_flag=false</span><br><span class="line">function precmd()&#123;</span><br><span class="line">    if $prompt_prefix_flag; then</span><br><span class="line">        echo &quot;&quot;</span><br><span class="line">    else</span><br><span class="line">        prompt_prefix_flag=true</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直在用zsh的主题ys。一直有一个很烦的问题，刚进入shell的时候最上面有一个空行看起来十分难受。&lt;br&gt;今天想起来解决了一下，发现并不困难。&lt;/p&gt;
&lt;p&gt;zsh的主题就是一个shell文件，修改变量PROMT就好了，而ys这个主题&lt;a href=&quot;https://g
      
    
    </summary>
    
      <category term="shell" scheme="https://ezksd.github.io/categories/shell/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust实现函数式列表</title>
    <link href="https://ezksd.github.io/2019/03/27/rust-functional-list/"/>
    <id>https://ezksd.github.io/2019/03/27/rust-functional-list/</id>
    <published>2019-03-27T15:49:18.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文有参考（Learn Rust With Entirely Too Many Linked Lists)[<a href="https://rust-unofficial.github.io/too-many-lists/index.html]%EF%BC%8C%E4%BD%86%E5%8E%9F%E6%96%87%E4%B8%AD%E8%B7%B3%E8%BF%87%E4%BA%86%E5%BE%88%E5%A4%9A%E9%9A%BE%E5%A4%84%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E6%AF%94%E5%A6%82%E7%94%A8Option%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%93%BE%E8%A1%A8%E5%92%8C%E8%8A%82%E7%82%B9%E5%88%86%E5%BC%80%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%98%BE%E7%84%B6%E8%BF%99%E6%98%BE%E7%84%B6%E5%BE%88%E4%B8%8D%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%82">https://rust-unofficial.github.io/too-many-lists/index.html]，但原文中跳过了很多难处理的情况，比如用Option代替代数数据类型，链表和节点分开定义，显然这显然很不函数式。</a></p></blockquote><p>Rust和Haskell非常相似，比如有ADT、模式匹配，trait/impl和class/instance几乎是一样的。<br>列表是函数式语言中最常用的数据结构，下面尝试在Rust中实现他。</p><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>在Haskell中List大概是这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Cons</span> a (<span class="type">List</span> <span class="title">a</span>) | <span class="type">Nil</span></span></span><br></pre></td></tr></table></figure><p>翻译成Rust：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&lt;T&gt;&#123;</span><br><span class="line">    Cons(T,List&lt;T&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0072]: recursive <span class="built_in">type</span> `List` has infinite size</span><br><span class="line"> --&gt; src/lib.rs:6:1</span><br><span class="line">  |</span><br><span class="line">6 | enum List&lt;T&gt;&#123;</span><br><span class="line">  | ^^^^^^^^^^^^ recursive <span class="built_in">type</span> has infinite size</span><br><span class="line">7 |     Cons(T,List&lt;T&gt;),</span><br><span class="line">  |            ------- recursive without indirection</span><br><span class="line">  |</span><br></pre></td></tr></table></figure><p>Rust需要在编译期知道知道结构体/枚举的大小，这里是递归的数据结构，而引用或是指针大小是固定的。涉及到引用就必须加上lifetime，然后它就变成了这样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&lt;<span class="symbol">&#x27;a</span>,T&gt;&#123;</span><br><span class="line">    Cons(T,&amp;<span class="symbol">&#x27;a</span> List&lt;<span class="symbol">&#x27;a</span>,T&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈上引用可能会出现悬挂指针的问题。</p><blockquote><p>cannot return value referencing temporary value<br>returns a value referencing data owned by the current function</p></blockquote><h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><blockquote><p>A pointer type for heap allocation.<br><code>Box&lt;T&gt;</code>, casually referred to as a ‘box’, provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.</p></blockquote><p>Box是在堆上分配的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&lt;T&gt; &#123;</span><br><span class="line">    Cons(T, <span class="built_in">Box</span>&lt;List&lt;T&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> List&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">range</span></span>(l: <span class="built_in">i32</span>, h: <span class="built_in">i32</span>) -&gt; List&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> l &lt; h &#123;</span><br><span class="line">            List::Cons(l, <span class="built_in">Box</span>::new(List::range(l + <span class="number">1</span>, h)))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List::Nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator需要实现的方法签名:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br></pre></td></tr></table></figure><p>对应不同类型的元素（Self::Item)，但结构体本身还是必要，因为需要保存中间遍历的位置。</p><ul><li>T -&gt; IntoIter</li><li>&amp;T -&gt; Iter</li><li>&amp;mut T -&gt; IterMut</li></ul><p>先从IntoIter开始，初步实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntoIter</span></span>&lt;T&gt;(List&lt;T&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> IntoIter&lt;T&gt;&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">            List::Cons(item,rest) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="number">0</span> = *rest;</span><br><span class="line">                <span class="literal">Some</span>(item)</span><br><span class="line">            &#125;</span><br><span class="line">            List::Nil =&gt; <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0507]: cannot <span class="keyword">move</span> out of `<span class="keyword">self</span>.<span class="number">0.1</span>` which is behind a mutable reference</span><br><span class="line">  --&gt; src/main.rs:<span class="number">21</span>:<span class="number">15</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |         <span class="keyword">match</span> <span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">   |               ^^^^^^ help: consider borrowing here: `&amp;<span class="keyword">self</span>.<span class="number">0</span>`</span><br><span class="line"><span class="number">22</span> |             List::Cons(item,rest) =&gt; &#123;</span><br><span class="line">   |                             ----</span><br><span class="line">   |                             |</span><br><span class="line">   |                             data moved here</span><br><span class="line">   |                             <span class="keyword">move</span> occurs because `rest` has <span class="class"><span class="keyword">type</span> `<span class="title">std</span></span>::boxed::<span class="built_in">Box</span>&lt;List&lt;T&gt;&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="class"><span class="keyword">trait</span></span></span><br><span class="line"><span class="class">           ^^^^ ^^^^</span></span><br></pre></td></tr></table></figure><p>List,Box均没有实现Copy，所以出现了move，但是引用没有所有权。</p><h2 id="std-mem-replace"><a href="#std-mem-replace" class="headerlink" title="std::mem::replace"></a>std::mem::replace</h2><p><a href="https://doc.rust-lang.org/std/mem/fn.replace.html">https://doc.rust-lang.org/std/mem/fn.replace.html</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">replace</span></span>&lt;T&gt;(dest: &amp;<span class="keyword">mut</span> T, src: T) -&gt; T</span><br><span class="line"><span class="comment">// Moves src into the referenced dest, returning the previous dest value.Neither value is dropped.</span></span><br></pre></td></tr></table></figure><p>先塞一个List::Nil进去把旧值换出来，这样就获得了旧值的所有权。Option的take方法就是replace的包装。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> &lt;T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> IntoIter&lt;T&gt;&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> std::mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span>,List::Nil) &#123;</span><br><span class="line">            List::Cons(item,rest) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="number">0</span> = *rest;</span><br><span class="line">                <span class="literal">Some</span>(item)</span><br><span class="line">            &#125;</span><br><span class="line">            List::Nil =&gt; <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iter（也就是Item类型为&amp;T）比较顺畅，因为有引用加上了生命周期，返回值和列表生命周期一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Iter</span></span>&lt;<span class="symbol">&#x27;a</span>,T&gt;(&amp;<span class="symbol">&#x27;a</span> List&lt;T&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> &lt;<span class="symbol">&#x27;a</span>,T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> Iter&lt;<span class="symbol">&#x27;a</span>,T&gt;&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = &amp;<span class="symbol">&#x27;a</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">            List::Cons(item,rest) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="number">0</span> = rest;</span><br><span class="line">                <span class="literal">Some</span>(item)</span><br><span class="line">            &#125;</span><br><span class="line">            List::Nil =&gt; <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是对于元素类型为&amp;mut T的迭代器又有新的问题。（像素级拷贝上述代码，就不贴了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">error[E0495]: cannot infer an appropriate lifetime <span class="keyword">for</span> pattern due to conflicting requirements</span><br><span class="line">  --&gt; src/main.rs:54:24</span><br><span class="line">   |</span><br><span class="line">54 |             List::Cons(item,rest) =&gt;&#123;</span><br><span class="line">   |                        ^^^^</span><br><span class="line">   |</span><br><span class="line">note: first, the lifetime cannot outlive the anonymous lifetime <span class="comment">#1 defined on the method body at 52:5...</span></span><br><span class="line">  --&gt; src/main.rs:52:5</span><br><span class="line">   |</span><br><span class="line">52 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">note: ...so that reference does not outlive borrowed content</span><br><span class="line">  --&gt; src/main.rs:54:24</span><br><span class="line">   |</span><br><span class="line">54 |             List::Cons(item,rest) =&gt;&#123;</span><br><span class="line">   |                        ^^^^</span><br><span class="line">note: but, the lifetime must be valid <span class="keyword">for</span> the lifetime `<span class="string">&#x27;a` as defined on the impl at 49:6...</span></span><br><span class="line"><span class="string">  --&gt; src/main.rs:49:6</span></span><br><span class="line"><span class="string">   |</span></span><br><span class="line"><span class="string">49 | impl&lt;&#x27;</span>a,T&gt; Iterator <span class="keyword">for</span> IterMut&lt;<span class="string">&#x27;a,T&gt;&#123;</span></span><br><span class="line"><span class="string">   |      ^^</span></span><br><span class="line"><span class="string">note: ...so that the types are compatible</span></span><br><span class="line"><span class="string">  --&gt; src/main.rs:52:46</span></span><br><span class="line"><span class="string">   |</span></span><br><span class="line"><span class="string">52 |       fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span></span><br><span class="line"><span class="string">   |  ______________________________________________^</span></span><br><span class="line"><span class="string">53 | |         match self.0 &#123;</span></span><br><span class="line"><span class="string">54 | |             List::Cons(item,rest) =&gt;&#123;</span></span><br><span class="line"><span class="string">55 | |                 self.0 = rest.as_mut();</span></span><br><span class="line"><span class="string">...  |</span></span><br><span class="line"><span class="string">63 | |         &#125;</span></span><br><span class="line"><span class="string">64 | |     &#125;</span></span><br><span class="line"><span class="string">   | |_____^</span></span><br><span class="line"><span class="string">   = note: expected `Iterator`</span></span><br><span class="line"><span class="string">              found `Iterator`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error[E0495]: cannot infer an appropriate lifetime for pattern due to conflicting requirements</span></span><br><span class="line"><span class="string">  --&gt; src/main.rs:54:29</span></span><br><span class="line"><span class="string">   |</span></span><br><span class="line"><span class="string">54 |             List::Cons(item,rest) =&gt;&#123;</span></span><br><span class="line"><span class="string">   |                             ^^^^</span></span><br><span class="line"><span class="string">   |</span></span><br><span class="line"><span class="string">note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 52:5...</span></span><br><span class="line"><span class="string">  --&gt; src/main.rs:52:5</span></span><br><span class="line"><span class="string">   |</span></span><br><span class="line"><span class="string">52 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span></span><br><span class="line"><span class="string">   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="string">note: ...so that reference does not outlive borrowed content</span></span><br><span class="line"><span class="string">  --&gt; src/main.rs:54:29</span></span><br><span class="line"><span class="string">   |</span></span><br><span class="line"><span class="string">54 |             List::Cons(item,rest) =&gt;&#123;</span></span><br><span class="line"><span class="string">   |                             ^^^^</span></span><br><span class="line"><span class="string">note: but, the lifetime must be valid for the lifetime `&#x27;</span>a` as defined on the impl at 49:6...</span><br><span class="line">  --&gt; src/main.rs:49:6</span><br><span class="line">   |</span><br><span class="line">49 | impl&lt;<span class="string">&#x27;a,T&gt; Iterator for IterMut&lt;&#x27;</span>a,T&gt;&#123;</span><br><span class="line">   |      ^^</span><br><span class="line">note: ...so that reference does not outlive borrowed content</span><br><span class="line">  --&gt; src/main.rs:55:26</span><br><span class="line">   |</span><br><span class="line">55 |                 self.0 = rest.as_mut();</span><br><span class="line">   |                          ^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure><p>这里self.0分裂成了两个不交叉的可变引用（这是合法的），但是后续self.0还依然持有self的可变引用，因此多个可变引用冲突。但报的是生命周期的错😅。</p><p>这一次需要替换的是引用，因此需要创建一个空指针，引用和指针但区别在于，引用是合法的，但指针可能是非法的，所以这里把引用替换出来，之后要注意把合法引用还回去。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>,T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> IterMut&lt;<span class="symbol">&#x27;a</span>,T&gt;&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> uninit = MaybeUninit::&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> List&lt;T&gt;&gt;::uninit();</span><br><span class="line">        <span class="keyword">match</span> std::mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span>,<span class="keyword">unsafe</span>&#123;uninit.assume_init()&#125;) &#123;</span><br><span class="line">            List::Cons(item,rest) =&gt;&#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="number">0</span> = rest.as_mut();</span><br><span class="line">                <span class="literal">Some</span>(item)</span><br><span class="line">            &#125;,</span><br><span class="line">            nil @ List::Nil =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="number">0</span> = nil;</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过既然用了unsafe，直接用<code>std::ptr::read</code>更简洁，而且这里读出来是引用，不用担心重复drop。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>,T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> IterMut&lt;<span class="symbol">&#x27;a</span>,T&gt;&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">unsafe</span>&#123;std::ptr::read(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span>)&#125; &#123;</span><br><span class="line">            List::Cons(item,rest) =&gt;&#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="number">0</span> = rest.as_mut();</span><br><span class="line">                <span class="literal">Some</span>(item)</span><br><span class="line">            &#125;,</span><br><span class="line">            nil @ List::Nil =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="number">0</span> = nil;</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><blockquote><p>unsafe警察出警！👮‍♀️<br>因为Rust的强语法限制，Rust的unsafe是非常值得了解的一块内容，而另一块是宏。unsafe也没有想象中那样简单，unsafe一套万事大吉。而前面两个例子比较简单但原因是涉及到的都是引用，不用担心忘记释放和重复释放的问题。</p></blockquote><p>让我们重新回顾一下引用和所有权规则。</p><ol><li>一个值同时可以有多个不可变引用</li><li>一个值同时可以有一个可变引用，可变引用存在的同时不能有不可变引用</li><li>引用的生命周期受生命周期限制</li></ol><p>而生命周期就是持有值的形式参数或局部变量的作用域，因为被包含在作用域内，由所有者释放就可以了，与此同时也不能超出生命周期。<br>而可变引用不同的地方在于他在赋予新值的时候，会释放旧值。</p><p>现在给他加一些小的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> List&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">range</span></span>(l: <span class="built_in">u32</span>, h: <span class="built_in">u32</span>) -&gt; List&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> r = List::Nil;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> t = h;</span><br><span class="line">        <span class="keyword">while</span> l &lt;= t &#123;</span><br><span class="line">            r = Cons(t,<span class="built_in">Box</span>::new(r));</span><br><span class="line">            t -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;A&gt; List&lt;A&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">into_iter</span></span>(<span class="keyword">self</span>) -&gt; IntoIter&lt;A&gt; &#123;</span><br><span class="line">        IntoIter(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">iter</span></span>(&amp;<span class="keyword">self</span>) -&gt; Iter&lt;A&gt; &#123;</span><br><span class="line">        Iter(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">iter_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; IterMut&lt;A&gt; &#123;</span><br><span class="line">        IterMut(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = List::range(<span class="number">1</span>, <span class="number">100_000_000</span>).into_iter().fold(<span class="number">0</span>, |_,a| a);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.46s</span><br><span class="line">     Running `target/debug/temp`</span><br><span class="line">100000000%</span><br></pre></td></tr></table></figure><p>没有问题</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = List::range(<span class="number">1</span>, <span class="number">100_000_000</span>).iter().fold(<span class="number">0</span>, |_,a| *a);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>💥Boom</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> has overflowed its stack</span><br><span class="line">fatal runtime error: stack overflow</span><br><span class="line">[1]    15047 abort (core dumped)  cargo run</span><br></pre></td></tr></table></figure><p>调试一下<br><img src="/images/rust.png" alt="debug"><br>递归drop爆栈，而第一段不爆是因为手动展开了</p><blockquote><p><strong>After drop is run, Rust will recursively try to drop all of the fields of self.</strong><br>This is a convenience feature so that you don’t have to write “destructor boilerplate” to drop children. If a struct has no special logic for being dropped other than dropping its children, then it means Drop doesn’t need to be implemented at all!<br><strong>There is no stable way to prevent this behavior in Rust 1.0.</strong></p></blockquote><p>如果手动实现Drop，但这里链表和节点是一体的。而对List实现了Drop之后无法通过模式匹配取值，只能取引用，这直接导致Drop实现异常复杂。（这是原博跳过的地方，而且原博既然提到函数式，没有理由用一个结构体来保存链表的头）</p><p>由于实现Drop之后无法move，这里用std::ptr::read。read是复制，因此是合法的。这里要十分注意，不然可能会出现重复释放。要么调用forget，不做清理，要么用std::ptr::write写回去，而write是直接覆盖，不会释放旧值。</p><p>另外，栈上的变量本身就不需要显式释放，函数调用完毕，栈帧收缩自动就释放了，所以这里核心是堆上的结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> &lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> List&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> t = std::ptr::read(<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">let</span> Cons(_,xs) = &amp;t &#123;</span><br><span class="line">                <span class="keyword">let</span> next = std::ptr::read(xs);</span><br><span class="line">                std::ptr::write(&amp;<span class="keyword">mut</span> t, *next);</span><br><span class="line">            &#125;</span><br><span class="line">            std::ptr::write(<span class="keyword">self</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Drop之后IntoIter也需要修改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> IntoIter&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> &amp;<span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">            Cons(item, rest) =&gt; &#123;</span><br><span class="line">                <span class="keyword">unsafe</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> x = std::ptr::read(item);</span><br><span class="line">                    <span class="keyword">let</span> xs = std::ptr::read(rest);</span><br><span class="line">                    std::ptr::write(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span>, *xs);</span><br><span class="line">                    <span class="literal">Some</span>(x)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文有参考（Learn Rust With Entirely Too Many Linked Lists)[&lt;a href=&quot;https://rust-unofficial.github.io/too-many-lists/index.html]%
      
    
    </summary>
    
      <category term="rust" scheme="https://ezksd.github.io/categories/rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Debug OpenJDK</title>
    <link href="https://ezksd.github.io/2018/11/17/debug-jdk/"/>
    <id>https://ezksd.github.io/2018/11/17/debug-jdk/</id>
    <published>2018-11-17T20:13:16.000Z</published>
    <updated>2021-06-26T13:14:30.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>系统： ubuntu 18.10</li><li>编辑器： vscode</li><li>JDK版本： openjdk8u</li></ul><h2 id="下载Openjdk"><a href="#下载Openjdk" class="headerlink" title="下载Openjdk"></a>下载Openjdk</h2><p>各版本都在<a href="https://hg.openjdk.java.net/">https://hg.openjdk.java.net</a>，这里选择jdk8u。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hg clone https://hg.openjdk.java.net/jdk8u/jdk8u openjdk</span><br><span class="line">cd openjdk</span><br><span class="line">chmod u+x get_source.sh </span><br><span class="line">./get_source.sh </span><br></pre></td></tr></table></figure><p>hg命令需要事先安装Mercurial.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mercurial</span><br></pre></td></tr></table></figure><p>如果下载缓慢尝试设置代理,在<code>/etc/mercurial/hgrc</code>文件里加入（真的非常慢）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> system-wide mercurial configuration file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See hgrc(5) <span class="keyword">for</span> more information</span></span><br><span class="line">[http_proxy]</span><br><span class="line">host=host:port</span><br><span class="line">[https_proxy]</span><br><span class="line">host=host:port</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译jdk需要系统已经安装了JDK，称为bootstrap jdk（而且最好是前一个版本，比如编译jdk8，那么事先装好jdk7），如果不对可以通过修改环境变量或者加上configure参数<code>--with-boot-jdk</code>参数指定jdk路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">openjdk version &quot;1.8.0_181&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_181-8u181-b13-1ubuntu0.18.10.1-b13)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure><p>安装依赖（参考<code>README</code>，也可以<code>configure</code>之后依据提示安装）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x configure</span><br><span class="line">$ ./configure --enable-debug --with-native-debug-symbols=external</span><br></pre></td></tr></table></figure><p>debug-level分slowdebug和fastdebug，–enable-debug默认位fast-debug，debug symbol默认是压缩的，设置–with-native-debug-symbols=external免去手动解压的工作。</p><p>将<code>hotspot/make/linux/makefiles/gcc.make</code>中的<code>WARNINGS_ARE_ERRORS = -Werror</code>改为<code>WARNINGS_ARE_ERRORS = -w</code>，不然会出现如下异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1plus: all warnings being treated as errors</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></table></figure><p>完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">build/linux-x86_64-normal-server-fastdebug/jdk/bin/java -version</span><br><span class="line">openjdk version &quot;1.8.0-normal-fastdebug&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0-internal-fastdebug)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.71-b00-fastdebug, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>vscode需要先装上<code>cpptools</code>插件，可以直接在插件商城里搜索<code>c/c++</code>。</p><p>打开VSCode, File -&gt; OpenFolder选中jdk文件夹，点击左侧虫虫图标，点击add configuration选中c/c++ (gdb) Launch,修改<code>lauch.json</code>文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;-cp&quot;</span>, <span class="string">&quot;~/Desktop&quot;</span>,<span class="string">&quot;Hello&quot;</span>],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">//&quot;sourceFileMap&quot;:&#123;&quot;/build/glibc-YYA7BZ/glibc-2.31&quot;: &quot;/usr/src/glibc/glibc-2.31&quot;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要修改program参数和args参数，program设置为<code>build/linux-x86_64-normal-server-fastdebug/jdk/bin/java</code>，args设置为编译好的class类名（我放在桌面），断点打在<code>src/share/vm/prims/jni.cpp</code>文件下的<code>JNI_CreateJavaVM</code>函数上，这里是jvm的入口，你也可以打在<code>jdk/src/share/bin/main.c</code> 的main函数上，这样差不多就可以开始调了，但是查看文件会非常多的错误提示找不到文件。</p><p>接下来在<code>.vscode</code>文件夹下创建<code>c_cpp_properties.json</code>文件，输入以下内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/hotspot/src/**&quot;</span>, <span class="comment">//hotspot源文件</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/build/linux-x86_64-normal-server-slowdebug/hotspot/linux_amd64_compiler2/generated/**&quot;</span>, <span class="comment">//编译生成的代码</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/jdk/src/**&quot;</span>, <span class="comment">//jdk根目录，其中包括大部分的可执行文件的源文件比如java，javac，还有一些native方法的实现</span></span><br><span class="line">                <span class="string">&quot;/usr/src/glibc/glibc-2.31/**&quot;</span> , <span class="comment">//libc源代码</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;c99&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++98&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个问题就是调试遇到<code>libc</code>里的函数的时候会弹窗提示找不到对应的文件，首先按照系统提示安装对应版本的<code>glibc</code>源文件，也可以手动下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install glibc-source</span><br></pre></td></tr></table></figure><p>我这里版本是glibc-2.31，安装在<code>/usr/src/glibc/glibc-2.31.tar.xz</code>，解压在当前目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/src/glibc</span><br><span class="line">tar -xvf glibc-2.29.tar.xz</span><br></pre></td></tr></table></figure><p>接下来，在弹错误的时候注意提示文件路径，比如我这里是<code>/build/glibc-KRRWSm/glibc-2.29</code>，在<code>launch.json</code>的<code>configurations</code>里面加入<code>&quot;sourceFileMap&quot;:&#123;&quot;/build/glibc-KRRWSm/glibc-2.29&quot;: &quot;/usr/src/glibc/glibc-2.29&quot;&#125;</code>。<code>sourceFileMap</code>配置可以参考下面的文档：<a href="https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#source-path-remapping">https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#source-path-remapping</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;系统： ubuntu 18.10&lt;/li&gt;
&lt;li&gt;编辑器： vscode&lt;/li&gt;
&lt;li&gt;JDK版本： openjdk8u&lt;
      
    
    </summary>
    
      <category term="jvm" scheme="https://ezksd.github.io/categories/jvm/"/>
    
      <category term="vscode" scheme="https://ezksd.github.io/categories/vscode/"/>
    
    
  </entry>
  
</feed>
